const m=new Map;const n=new Map;const o=new Map;const p=new Set;p.CreateTreeHookCache=new Set;p.CreateNodeHookCache=new Set;p.SyncTreeHookCache=new Set;p.ReleaseHookCache=new Set;const S=10000;const T=new Set;const U=new Set;const V=new Set;const W=()=>({rawNodeName:"",nodeName:"",nodeValue:"",nodeType:1,key:"",childNodes:[],attributes:{}});const X={free:T,allocated:U,protected:V};for(let i=0;i<S;i++){T.add(W())}const Y=T.values();const{CreateTreeHookCache:Z}=p;const{isArray:aa}=Array;const bb="#document-fragment";const{CreateNodeHookCache:cc}=p;const dd="http://www.w3.org/2000/svg";const ee=/\S/;const ff=/<!.*>/i;const gg=/\b([_a-z][_a-z0-9\-:]*)\s*(=\s*("([^"]+)"|'([^']+)'|(\S+)))?/ig;const hh=/[^ ]/;const ii=/__DIFFHTML__([^_]*)__/;const jj=/<!--[^]*?(?=-->)-->|<(\/?)([a-z\-\_][a-z0-9\-\_]*)\s*([^>]*?)(\/?)>/ig;const{assign:kk}=Object;const{isArray:ll}=Array;const mm=new Set(["script","noscript","style","code","template"]);const nn=new Set(["meta","img","link","input","area","br","hr","area","base","br","col","embed","hr","img","input","keygen","link","meta","param","source","track","wbr"]);const oo={li:{li:!0},p:{p:!0,div:!0},td:{td:!0,th:!0},th:{td:!0,th:!0}};const pp={li:{ul:!0,ol:!0},a:{div:!0},b:{div:!0},i:{div:!0},p:{div:!0},td:{tr:!0,table:!0},th:{tr:!0,table:!0}};const qq=(currentParent,string,supplemental={})=>{const childNodes=[];const parts=string.split(ii);let{length}=parts;for(let i=0;i<parts.length;i++){const value=parts[i];if(i%2===1){const innerTree=supplemental.children[value];const isFragment=innerTree.nodeType===11;if(typeof innerTree.rawNodeName==="string"&&isFragment){childNodes.push(...innerTree.childNodes)}else{childNodes.push(innerTree)}}else!ff.test(value)&&childNodes.push(l("#text",value))}currentParent.childNodes.push(...childNodes)};const rr=(nodeName,rawAttrs,supplemental,options)=>{let match=null;const attributes={};for(let match;match=gg.exec(rawAttrs||"");){const name=match[1];const value=match[6]||match[5]||match[4]||match[1];let tokenMatch=value.match(ii);if(tokenMatch&&tokenMatch.length){const parts=value.split(ii);let{length}=parts;const hasToken=ii.exec(name);const newName=hasToken?supplemental.attributes[hasToken[1]]:name;for(let i=0;i<parts.length;i++){const value=parts[i];if(i%2===1){if(attributes[newName]){attributes[newName]+=supplemental.attributes[value]}else{const isObject=typeof newName==="object";if(isObject&&!ll(newName)&&newName){kk(attributes,newName)}else if(isObject&&options.strict){if(s.env.NODE_ENV!=="production"){gg.lastIndex=0;jj.lastIndex=0;throw new Error("Arrays are not allowed to be spread in strict mode")}}else newName&&typeof newName!=="object"&&(attributes[newName]=supplemental.attributes[value])}}else{if(attributes[newName]){attributes[newName]+=value}else{attributes[newName]=value}}}}else if(tokenMatch=ii.exec(name)){const nameAndValue=supplemental.attributes[tokenMatch[1]];const hasToken=ii.exec(value);const getValue=hasToken?supplemental.attributes[hasToken[1]]:value;attributes[nameAndValue]=value==="\"\""?"":getValue}else{attributes[name]=value==="\"\""?"":value}}return l(nodeName,attributes,[])};const{ReleaseHookCache:ss}=p;const{memory:tt,protect:uu,unprotect:vv}=q;function protectVTree(vTree){uu(vTree);for(let i=0;i<vTree.childNodes.length;i++){protectVTree(vTree.childNodes[i])}return vTree}function unprotectVTree(vTree){vv(vTree);ss.size&&ss.forEach(fn=>fn(vTree));for(let i=0;i<vTree.childNodes.length;i++){unprotectVTree(vTree.childNodes[i])}return vTree}function cleanMemory(isBusy=!1){m.forEach(state=>isBusy=isBusy||state.isRendering);if(!isBusy){tt.allocated.forEach(vTree=>tt.free.add(vTree));tt.allocated.clear();n.forEach((node,vTree)=>{if(!tt.protected.has(vTree)){n.delete(vTree);ss.size&&ss.forEach(fn=>fn(vTree))}})}}const ww=typeof global==="object"?global:window;const xx=ww.document?document.createElement("div"):null;const z=new Map;const A="diffHTML";const yy="diff_perf";const zz=typeof location!=="undefined";const AA=typeof process!=="undefined"&&process.argv;const BB=()=>{};const{assign:CC}=Object;const{SyncTreeHookCache:DD}=p;const EE={};const FF=["old","new"];const GG=["attached","detached","replaced","attributeChanged","textChanged"];GG.forEach(stateName=>o.set(stateName,new Set));function addTransitionState(stateName,callback){if(s.env.NODE_ENV!=="production"){}o.get(stateName).add(callback)}function removeTransitionState(stateName,callback){if(!callback&&stateName){o.get(stateName).clear()}else if(stateName&&callback){o.get(stateName).delete(callback)}else{for(let i=0;i<GG.length;i++){o.get(GG[i]).clear()}}}function runTransitions(setName,...args){const set=o.get(setName);const promises=[];set.forEach(callback=>{const retVal=callback(...args);typeof retVal==="object"&&retVal.then&&promises.push(retVal)});if(setName==="attached"||setName==="detached"||setName==="replaced"){const element=args[0];[...element.childNodes].forEach(childNode=>{promises.push(...runTransitions(setName,childNode,...args.slice(1)))})}return promises}const HH=new Set(["script","noscript","style","code","template"]);const II=new Set;const JJ=new Set;const KK=(domNode,name)=>{domNode.removeAttribute(name);const blacklistName=domNode.nodeName+"-"+name;if(JJ.has(blacklistName)){domNode[name]=void 0}else{}};const D=[G,H,v,I,K,M];const E={schedule:G,shouldUpdate:H,reconcileTrees:v,syncTrees:I,patchNode:K,endAsPromise:M};const{isArray:LL}=Array;const MM=/(<|\/)/;const NN="__DIFFHTML__";const OO=values=>{const value=values.shift();return typeof value==="string"?y(x(value)):value};O.strict=(...args)=>{O.isStrict=!0;return O(...args)};const{CreateTreeHookCache:PP,CreateNodeHookCache:QQ,SyncTreeHookCache:RR,ReleaseHookCache:SS}=p;const R="1.0.0-beta.9";D.splice(D.indexOf(v),0,t);const TT={VERSION:R,addTransitionState,removeTransitionState,release:P,createTree:l,use:Q,outerHTML:N,innerHTML:C,html:O};const{assign:UU}=Object;const j=UU(w,TT,{parse:u,defaultTasks:D,tasks:E,createNode:r,syncTree:l});TT.Internals=j;if(typeof devTools!=="undefined"){Q(devTools(j));console.warn("diffHTML DevTools: Found and Activated...")}this.diffhtml=TT;