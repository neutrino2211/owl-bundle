'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.protectVTree = protectVTree;
exports.unprotectVTree = unprotectVTree;
exports.cleanMemory = cleanMemory;

var _pool = require('./pool');

var _pool2 = _interopRequireDefault(_pool);

var _caches = require('./caches');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const { ReleaseHookCache } = _caches.MiddlewareCache;
const { memory, protect, unprotect } = _pool2.default;

/**
 * Ensures that an vTree is not recycled during a render cycle.
 *
 * @param vTree
 * @return vTree
 */
function protectVTree(vTree) {
  protect(vTree);

  for (let i = 0; i < vTree.childNodes.length; i++) {
    protectVTree(vTree.childNodes[i]);
  }

  return vTree;
}

/**
 * Allows an vTree to be recycled during a render cycle.
 *
 * @param vTree
 * @return
 */
function unprotectVTree(vTree) {
  unprotect(vTree);

  if (ReleaseHookCache.size) {
    ReleaseHookCache.forEach(fn => fn(vTree));
  }

  for (let i = 0; i < vTree.childNodes.length; i++) {
    unprotectVTree(vTree.childNodes[i]);
  }

  return vTree;
}

/**
 * Moves all unprotected allocations back into available pool. This keeps
 * diffHTML in a consistent state after synchronizing.
 */
function cleanMemory(isBusy = false) {
  _caches.StateCache.forEach(state => isBusy = isBusy || state.isRendering);

  // Clean out unused elements, if we have any elements cached that no longer
  // have a backing VTree, we can safely remove them from the cache.
  if (!isBusy) {
    memory.allocated.forEach(vTree => memory.free.add(vTree));
    memory.allocated.clear();

    _caches.NodeCache.forEach((node, vTree) => {
      if (!memory.protected.has(vTree)) {
        _caches.NodeCache.delete(vTree);

        if (ReleaseHookCache.size) {
          ReleaseHookCache.forEach(fn => fn(vTree));
        }
      }
    });
  }
}