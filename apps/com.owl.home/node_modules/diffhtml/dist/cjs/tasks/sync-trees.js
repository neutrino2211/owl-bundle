'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = syncTrees;

var _sync = require('../tree/sync');

var _sync2 = _interopRequireDefault(_sync);

var _create = require('../node/create');

var _create2 = _interopRequireDefault(_create);

var _caches = require('../util/caches');

var _memory = require('../util/memory');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function syncTrees(transaction) {
  const { state: { measure }, oldTree, newTree, domNode } = transaction;

  measure('sync trees');

  // Do a global replace of the element, unable to do this at a lower level.
  // Ignore this for document fragments, they don't appear in the DOM and we
  // treat them as transparent containers.
  if (oldTree.nodeName !== newTree.nodeName && newTree.nodeType !== 11) {
    // If there is no `parentNode` for the replace operation, we will need to
    // throw an error and prevent the `StateCache` from being updated.
    if (!domNode.parentNode) {
      throw new Error('Unable to replace top level node without a parent');
    }

    transaction.patches = {
      TREE_OPS: [{ REPLACE_CHILD: [newTree, oldTree] }],
      SET_ATTRIBUTE: [],
      REMOVE_ATTRIBUTE: [],
      NODE_VALUE: []
    };

    (0, _memory.unprotectVTree)(transaction.oldTree);
    transaction.oldTree = transaction.state.oldTree = newTree;
    (0, _memory.protectVTree)(transaction.oldTree);

    // Update the StateCache since we are changing the top level element.
    _caches.StateCache.delete(domNode);
    _caches.StateCache.set((0, _create2.default)(newTree), transaction.state);
  }
  // Otherwise only diff the children.
  else {
      transaction.patches = (0, _sync2.default)(oldTree, newTree);
    }

  measure('sync trees');
}
module.exports = exports['default'];