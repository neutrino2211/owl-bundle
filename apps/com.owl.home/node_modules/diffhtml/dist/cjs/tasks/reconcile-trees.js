'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = reconcileTrees;

var _caches = require('../util/caches');

var _memory = require('../util/memory');

var _create = require('../tree/create');

var _create2 = _interopRequireDefault(_create);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function reconcileTrees(transaction) {
  const { state, domNode, markup, options } = transaction;
  const { previousMarkup } = state;
  const { inner } = options;
  const { outerHTML } = domNode;

  // We rebuild the tree whenever the DOM Node changes, including the first
  // time we patch a DOM Node.
  if (previousMarkup !== outerHTML || !state.oldTree || !outerHTML) {
    if (state.oldTree) {
      (0, _memory.unprotectVTree)(state.oldTree);
    }

    state.oldTree = (0, _create2.default)(domNode);
    _caches.NodeCache.set(state.oldTree, domNode);
    (0, _memory.protectVTree)(state.oldTree);
  }

  // Associate the old tree with this brand new transaction.
  transaction.oldTree = state.oldTree;

  // If we are in a render transaction where no markup was previously parsed
  // then reconcile trees will attempt to create a tree based on the incoming
  // markup (JSX/html/etc).
  if (!transaction.newTree) {
    transaction.newTree = (0, _create2.default)(markup);
  }

  // If we are diffing only the parent's childNodes, then adjust the newTree to
  // be a replica of the oldTree except with the childNodes changed.
  if (inner) {
    const { oldTree, newTree } = transaction;
    const { rawNodeName, nodeName, attributes } = oldTree;
    const isUnknown = typeof newTree.rawNodeName !== 'string';
    const isFragment = newTree.nodeType === 11;
    const children = isFragment && !isUnknown ? newTree.childNodes : newTree;

    transaction.newTree = (0, _create2.default)(nodeName, attributes, children);
  }
}
module.exports = exports['default'];