'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = patchNode;

var _create = require('./create');

var _create2 = _interopRequireDefault(_create);

var _transition = require('../transition');

var _caches = require('../util/caches');

var _memory = require('../util/memory');

var _decodeEntities = require('../util/decode-entities');

var _decodeEntities2 = _interopRequireDefault(_decodeEntities);

var _escape = require('../util/escape');

var _escape2 = _interopRequireDefault(_escape);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const blockText = new Set(['script', 'noscript', 'style', 'code', 'template']);
const blacklist = new Set();
const whitelist = new Set();

const removeAttribute = (domNode, name) => {
  domNode.removeAttribute(name);

  // Runtime checking if the property can be set.
  const blacklistName = domNode.nodeName + '-' + name;

  if (whitelist.has(blacklistName)) {
    domNode[name] = undefined;
  } else if (!blacklist.has(blacklistName)) {
    try {
      domNode[name] = undefined;
      whitelist.add(blacklistName);
    } catch (unhandledException) {
      blacklist.add(blacklistName);
    }
  }
};

function patchNode(patches, state = {}) {
  const promises = [];
  const { TREE_OPS, NODE_VALUE, SET_ATTRIBUTE, REMOVE_ATTRIBUTE } = patches;
  const { isSVG, ownerDocument } = state;

  // Set attributes.
  if (SET_ATTRIBUTE.length) {
    for (let i = 0; i < SET_ATTRIBUTE.length; i += 3) {
      const vTree = SET_ATTRIBUTE[i];
      const _name = SET_ATTRIBUTE[i + 1];
      const value = (0, _decodeEntities2.default)(SET_ATTRIBUTE[i + 2]);

      const domNode = (0, _create2.default)(vTree, ownerDocument, isSVG);
      const oldValue = domNode.getAttribute(_name);
      const newPromises = (0, _transition.runTransitions)('attributeChanged', domNode, _name, oldValue, value);

      // Triggered either synchronously or asynchronously depending on if a
      // transition was invoked.
      const isObject = typeof value === 'object';
      const isFunction = typeof value === 'function';

      // Events must be lowercased otherwise they will not be set correctly.
      const name = _name.indexOf('on') === 0 ? _name.toLowerCase() : _name;

      // Runtime checking if the property can be set.
      const blacklistName = vTree.nodeName + '-' + name;

      // Normal attribute value.
      if (!isObject && !isFunction && name) {
        const noValue = value === null || value === undefined;

        if (whitelist.has(blacklistName)) {
          domNode[name] = value;
        } else if (!blacklist.has(blacklistName)) {
          try {
            domNode[name] = value;
            whitelist.add(blacklistName);
          } catch (unhandledException) {
            blacklist.add(blacklistName);
          }
        }

        // Set the actual attribute, this will ensure attributes like
        // `autofocus` aren't reset by the property call above.
        domNode.setAttribute(name, noValue ? '' : value);
      }
      // Support patching an object representation of the style object.
      else if (isObject && name === 'style') {
          const keys = Object.keys(value);

          for (let i = 0; i < keys.length; i++) {
            domNode.style[keys[i]] = value[keys[i]];
          }
        } else if (typeof value !== 'string') {
          // Since this is a property value it gets set directly on the node.
          if (whitelist.has(blacklistName)) {
            domNode[name] = value;
          } else if (!blacklist.has(blacklistName)) {
            try {
              domNode[name] = value;
              whitelist.add(blacklistName);
            } catch (unhandledException) {
              blacklist.add(blacklistName);
            }
          }
        }

      if (newPromises.length) {
        promises.push(...newPromises);
      }
    }
  }

  // Remove attributes.
  if (REMOVE_ATTRIBUTE.length) {
    for (let i = 0; i < REMOVE_ATTRIBUTE.length; i += 2) {
      const vTree = REMOVE_ATTRIBUTE[i];
      const name = REMOVE_ATTRIBUTE[i + 1];

      const domNode = _caches.NodeCache.get(vTree);
      const attributeChanged = _caches.TransitionCache.get('attributeChanged');

      const oldValue = domNode.getAttribute(name);
      const newPromises = (0, _transition.runTransitions)('attributeChanged', domNode, name, oldValue, null);

      if (newPromises.length) {
        Promise.all(newPromises).then(() => removeAttribute(domNode, name));
        promises.push(...newPromises);
      } else {
        removeAttribute(domNode, name);
      }
    }
  }

  // Once attributes have been synchronized into the DOM Nodes, assemble the
  // DOM Tree.
  for (let i = 0; i < TREE_OPS.length; i++) {
    const { INSERT_BEFORE, REMOVE_CHILD, REPLACE_CHILD } = TREE_OPS[i];

    // Insert/append elements.
    if (INSERT_BEFORE && INSERT_BEFORE.length) {
      for (let i = 0; i < INSERT_BEFORE.length; i += 3) {
        const vTree = INSERT_BEFORE[i];
        const newTree = INSERT_BEFORE[i + 1];
        const refTree = INSERT_BEFORE[i + 2];

        const domNode = _caches.NodeCache.get(vTree);
        const refNode = refTree && (0, _create2.default)(refTree, ownerDocument, isSVG);
        const attached = _caches.TransitionCache.get('attached');

        if (refTree) {
          (0, _memory.protectVTree)(refTree);
        }

        const newNode = (0, _create2.default)(newTree, ownerDocument, isSVG);
        (0, _memory.protectVTree)(newTree);

        // If refNode is `null` then it will simply append like `appendChild`.
        domNode.insertBefore(newNode, refNode);

        const attachedPromises = (0, _transition.runTransitions)('attached', newNode);

        promises.push(...attachedPromises);
      }
    }

    // Remove elements.
    if (REMOVE_CHILD && REMOVE_CHILD.length) {
      for (let i = 0; i < REMOVE_CHILD.length; i++) {
        const vTree = REMOVE_CHILD[i];
        const domNode = _caches.NodeCache.get(vTree);
        const detached = _caches.TransitionCache.get('detached');
        const detachedPromises = (0, _transition.runTransitions)('detached', domNode);

        if (detachedPromises.length) {
          Promise.all(detachedPromises).then(() => {
            domNode.parentNode.removeChild(domNode);
            (0, _memory.unprotectVTree)(vTree);
          });

          promises.push(...detachedPromises);
        } else {
          domNode.parentNode.removeChild(domNode);
          (0, _memory.unprotectVTree)(vTree);
        }
      }
    }

    // Replace elements.
    if (REPLACE_CHILD && REPLACE_CHILD.length) {
      for (let i = 0; i < REPLACE_CHILD.length; i += 2) {
        const newTree = REPLACE_CHILD[i];
        const oldTree = REPLACE_CHILD[i + 1];

        const oldDomNode = _caches.NodeCache.get(oldTree);
        const newDomNode = (0, _create2.default)(newTree, ownerDocument, isSVG);
        const attached = _caches.TransitionCache.get('attached');
        const detached = _caches.TransitionCache.get('detached');
        const replaced = _caches.TransitionCache.get('replaced');

        // Always insert before to allow the element to transition.
        oldDomNode.parentNode.insertBefore(newDomNode, oldDomNode);
        (0, _memory.protectVTree)(newTree);

        const attachedPromises = (0, _transition.runTransitions)('attached', newDomNode);
        const detachedPromises = (0, _transition.runTransitions)('detached', oldDomNode);
        const replacedPromises = (0, _transition.runTransitions)('replaced', oldDomNode, newDomNode);
        const allPromises = [...attachedPromises, ...detachedPromises, ...replacedPromises];

        if (allPromises.length) {
          Promise.all(allPromises).then(() => {
            oldDomNode.parentNode.replaceChild(newDomNode, oldDomNode);
            (0, _memory.unprotectVTree)(oldTree);
          });

          promises.push(...allPromises);
        } else {
          oldDomNode.parentNode.replaceChild(newDomNode, oldDomNode);
          (0, _memory.unprotectVTree)(oldTree);
        }
      }
    }
  }

  // Change all nodeValues.
  if (NODE_VALUE.length) {
    for (let i = 0; i < NODE_VALUE.length; i += 3) {
      const vTree = NODE_VALUE[i];
      const nodeValue = NODE_VALUE[i + 1];
      const oldValue = NODE_VALUE[i + 2];
      const domNode = (0, _create2.default)(vTree);
      const textChanged = _caches.TransitionCache.get('textChanged');
      const textChangedPromises = (0, _transition.runTransitions)('textChanged', domNode, oldValue, nodeValue);

      const { parentNode } = domNode;

      if (nodeValue.includes('&')) {
        domNode.nodeValue = (0, _decodeEntities2.default)(nodeValue);
      } else {
        domNode.nodeValue = nodeValue;
      }

      if (parentNode && blockText.has(parentNode.nodeName.toLowerCase())) {
        parentNode.nodeValue = (0, _escape2.default)((0, _decodeEntities2.default)(nodeValue));
      }

      if (textChangedPromises.length) {
        promises.push(...textChangedPromises);
      }
    }
  }

  return promises;
}
module.exports = exports['default'];