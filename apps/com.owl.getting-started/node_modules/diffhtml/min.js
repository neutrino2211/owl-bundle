const StateCache=new Map;const NodeCache=new Map;const TransitionCache=new Map;const MiddlewareCache=new Set;MiddlewareCache.CreateTreeHookCache=new Set;MiddlewareCache.CreateNodeHookCache=new Set;MiddlewareCache.SyncTreeHookCache=new Set;MiddlewareCache.ReleaseHookCache=new Set;const size=1e4;const free=new Set;const allocate=new Set;const protect=new Set;const shape=()=>({rawNodeName:"",nodeName:"",nodeValue:"",nodeType:1,key:"",childNodes:[],attributes:{}});const memory={free:free,allocated:allocate,protected:protect};for(let i=0;i<size;i++){free.add(shape())}let freeValues=free.values();const pool_default_0={size:size,memory:memory,get(){const{value:value=shape(),done:done}=freeValues.next();if(done){freeValues=free.values()}free.delete(value);allocate.add(value);return value},protect(value){allocate.delete(value);protect.add(value)},unprotect(value){if(protect.has(value)){protect.delete(value);free.add(value)}}};const{CreateTreeHookCache:CreateTreeHookCache}=MiddlewareCache;const{isArray:isArray}=Array;const fragmentName="#document-fragment";const create_default_0=function createTree(input,attributes,childNodes,...rest){if(!input){return null}if(isArray(input)){childNodes=[];for(let i=0;i<input.length;i++){const newTree=create_default_0(input[i]);if(!newTree){continue}const isFragment=newTree.nodeType===11;if(typeof newTree.rawNodeName==="string"&&isFragment){childNodes.push(...newTree.childNodes)}else{childNodes.push(newTree)}}return create_default_0(fragmentName,null,childNodes)}const isObject=typeof input==="object";if(input&&isObject&&"parentNode"in input){attributes={};childNodes=[];if(input.nodeType===3){childNodes=input.nodeValue}else if(input.nodeType===1&&input.attributes.length){attributes={};for(let i=0;i<input.attributes.length;i++){const{name:name,value:value}=input.attributes[i];if(value===""&&name in input){attributes[name]=input[name];continue}attributes[name]=value}}if(input.nodeType===1||input.nodeType===11){if(input.childNodes.length){childNodes=[];for(let i=0;i<input.childNodes.length;i++){childNodes.push(create_default_0(input.childNodes[i]))}}}const vTree=create_default_0(input.nodeName,attributes,childNodes);NodeCache.set(vTree,input);return vTree}if(isObject){if("children"in input&&!("childNodes"in input)){const nodeName=input.nodeName||input.elementName;return create_default_0(nodeName,input.attributes,input.children)}return input}if(rest.length){childNodes=[childNodes,...rest]}const entry=pool_default_0.get();const isTextNode=input==="#text";const isString=typeof input==="string";entry.key="";entry.rawNodeName=input;entry.nodeName=isString?input.toLowerCase():"#document-fragment";entry.childNodes.length=0;entry.nodeValue="";entry.attributes={};if(isTextNode){const nodes=arguments.length===2?attributes:childNodes;const nodeValue=isArray(nodes)?nodes.join(""):nodes;entry.nodeType=3;entry.nodeValue=String(nodeValue||"");return entry}if(input===fragmentName||typeof input!=="string"){entry.nodeType=11}else if(input==="#comment"){entry.nodeType=8}else{entry.nodeType=1}const useAttributes=isArray(attributes)||typeof attributes!=="object";const nodes=useAttributes?attributes:childNodes;const nodeArray=isArray(nodes)?nodes:[nodes];if(nodes&&nodeArray.length){for(let i=0;i<nodeArray.length;i++){const newNode=nodeArray[i];const isNodeArray=isArray(newNode);if(isNodeArray){for(let i=0;i<newNode.length;i++){entry.childNodes.push(newNode[i])}}else if(!newNode){continue}else if(newNode.nodeType===11&&typeof newNode.rawNodeName==="string"){for(let i=0;i<newNode.childNodes.length;i++){entry.childNodes.push(newNode.childNodes[i])}}else if(newNode&&typeof newNode==="object"){entry.childNodes.push(newNode)}else if(newNode){entry.childNodes.push(create_default_0("#text",null,newNode))}}}if(attributes&&typeof attributes==="object"&&!isArray(attributes)){entry.attributes=attributes}if(entry.nodeName==="script"&&entry.attributes.src){entry.key=String(entry.attributes.src)}if(entry.attributes&&"key"in entry.attributes){entry.key=String(entry.attributes.key)}let vTree=entry;CreateTreeHookCache.forEach((fn,retVal)=>{if(retVal=fn(vTree)){vTree=retVal}});return vTree};const process_default_0=typeof process!=="undefined"?process:{env:{NODE_ENV:"development"}};const{CreateNodeHookCache:CreateNodeHookCache}=MiddlewareCache;const namespace="http://www.w3.org/2000/svg";const create_default_1=function createNode(vTree,ownerDocument=document,isSVG){if(process_default_0.env.NODE_ENV!=="production"){if(!vTree){throw new Error("Missing VTree when trying to create DOM Node")}}const existingNode=NodeCache.get(vTree);if(existingNode){if(existingNode.nodeName.toLowerCase()!==vTree.nodeName){throw new Error("Shit is wrong")}return existingNode}const{nodeName:nodeName,rawNodeName:rawNodeName=nodeName,childNodes:childNodes=[]}=vTree;isSVG=isSVG||nodeName==="svg";let domNode=null;CreateNodeHookCache.forEach((fn,retVal)=>{if(retVal=fn(vTree)){domNode=retVal}});if(!domNode){if(nodeName==="#text"){domNode=ownerDocument.createTextNode(vTree.nodeValue)}else if(nodeName==="#document-fragment"){domNode=ownerDocument.createDocumentFragment()}else if(isSVG){domNode=ownerDocument.createElementNS(namespace,rawNodeName)}else{domNode=ownerDocument.createElement(rawNodeName)}}NodeCache.set(vTree,domNode);for(let i=0;i<childNodes.length;i++){domNode.appendChild(create_default_1(childNodes[i],ownerDocument,isSVG))}return domNode};const g=typeof global==="object"?global:window;const element=g.document?document.createElement("div"):null;const decode_entities_default_0=function decodeEntities(string){if(!element||!string||!string.indexOf||!string.includes("&")){return string}element.innerHTML=string;return element.textContent};const escape_default_0=function escape(unescaped){return unescaped.replace(/[&<>]/g,match=>`&#${match.charCodeAt(0)};`)};const marks=new Map;const prefix="diffHTML";const DIFF_PERF="diff_perf";const hasSearch=typeof location!=="undefined";const hasArguments=typeof process!=="undefined"&&process.argv;const nop=()=>{};const make_measure_default_0=(domNode,vTree)=>{const wantsSearch=hasSearch&&location.search.includes(DIFF_PERF);const wantsArguments=hasArguments&&process.argv.includes(DIFF_PERF);const wantsPerfChecks=wantsSearch||wantsArguments;if(!wantsPerfChecks){return nop}return name=>{if(domNode&&domNode.host){name=`${domNode.host.constructor.name} ${name}`}else if(typeof vTree.rawNodeName==="function"){name=`${vTree.rawNodeName.name} ${name}`}const endName=`${name}-end`;if(!marks.has(name)){marks.set(name,performance.now());performance.mark(name)}else{const totalMs=(performance.now()-marks.get(name)).toFixed(3);marks.delete(name);performance.mark(endName);performance.measure(`${prefix} ${name} (${totalMs}ms)`,name,endName)}}};const{ReleaseHookCache:ReleaseHookCache}=MiddlewareCache;const{unprotect:unprotect}=pool_default_0;function protectVTree(vTree){protect(vTree);for(let i=0;i<vTree.childNodes.length;i++){protectVTree(vTree.childNodes[i])}return vTree}function unprotectVTree(vTree){unprotect(vTree);if(ReleaseHookCache.size){ReleaseHookCache.forEach(fn=>fn(vTree))}for(let i=0;i<vTree.childNodes.length;i++){unprotectVTree(vTree.childNodes[i])}return vTree}function cleanMemory(isBusy=false){StateCache.forEach(state=>isBusy=isBusy||state.isRendering);if(!isBusy){memory.allocated.forEach(vTree=>memory.free.add(vTree));memory.allocated.clear();NodeCache.forEach((node,vTree)=>{if(!memory.protected.has(vTree)){NodeCache.delete(vTree);if(ReleaseHookCache.size){ReleaseHookCache.forEach(fn=>fn(vTree))}}})}}const{assign:assign}=Object;const internals_default_0=assign({decodeEntities:decode_entities_default_0,escape:escape_default_0,makeMeasure:make_measure_default_0,memory:memory,Pool:pool_default_0,process:process_default_0},caches);const schedule_default_0=function schedule(transaction){let{state:state}=transaction;const{isRendering:isRendering,activeTransaction:activeTransaction,nextTransaction:nextTransaction}=state;if(isRendering){const{tasks:tasks}=transaction;const chainTransaction=nextTransaction||activeTransaction;state.nextTransaction=transaction;transaction.abort();const promise=chainTransaction.promise||Promise.resolve();return transaction.promise=promise.then(()=>{transaction.aborted=false;return transaction_default_0.flow(transaction,tasks.slice(1))})}state.isRendering=true;state.activeTransaction=transaction};const should_update_default_0=function shouldUpdate(transaction){const{domNode:domNode,markup:markup,state:state,state:{measure:measure},options:options}=transaction;const prop=options.inner?"innerHTML":"outerHTML";measure("should update");if(typeof markup==="string"&&domNode[prop]===markup){return transaction.abort(true)}else if(typeof markup==="string"){state.markup=markup}measure("should update")};const reconcile_trees_default_0=function reconcileTrees(transaction){const{state:state,domNode:domNode,markup:markup,options:options}=transaction;const{previousMarkup:previousMarkup}=state;const{inner:inner}=options;const{outerHTML:outerHTML}=domNode;if(previousMarkup!==outerHTML||!state.oldTree||!outerHTML){if(state.oldTree){unprotectVTree(state.oldTree)}state.oldTree=create_default_0(domNode);NodeCache.set(state.oldTree,domNode);protectVTree(state.oldTree)}transaction.oldTree=state.oldTree;if(!transaction.newTree){transaction.newTree=create_default_0(markup)}if(inner){const{oldTree:oldTree,newTree:newTree}=transaction;const{rawNodeName:rawNodeName,nodeName:nodeName,attributes:attributes}=oldTree;const isUnknown=typeof newTree.rawNodeName!=="string";const isFragment=newTree.nodeType===11;const children=isFragment&&!isUnknown?newTree.childNodes:newTree;transaction.newTree=create_default_0(nodeName,attributes,children)}};const{SyncTreeHookCache:SyncTreeHookCache}=MiddlewareCache;const empty={};const keyNames=["old","new"];const sync_default_0=function syncTree(oldTree,newTree,patches,parentTree,specialCase){if(!oldTree)oldTree=empty;if(!newTree)newTree=empty;const oldNodeName=oldTree.nodeName;const isFragment=newTree.nodeType===11;const isEmpty=oldTree===empty;const keysLookup={old:new Map,new:new Map};if(process_default_0.env.NODE_ENV!=="production"){if(newTree===empty){throw new Error("Missing new Virtual Tree to sync changes from")}if(!isEmpty&&oldNodeName!==newTree.nodeName&&!isFragment){throw new Error(`Sync failure, cannot compare ${newTree.nodeName} with ${oldNodeName}`)}}for(let i=0;i<keyNames.length;i++){const keyName=keyNames[i];const map=keysLookup[keyName];const vTree=arguments[i];const nodes=vTree&&vTree.childNodes;if(nodes&&nodes.length){for(let i=0;i<nodes.length;i++){const vTree=nodes[i];if(vTree.key){if(process_default_0.env.NODE_ENV!=="production"){if(map.has(vTree.key)){throw new Error(`Key: ${vTree.key} cannot be duplicated`)}}map.set(vTree.key,vTree)}}}}let shortCircuit=false;patches=patches||{SET_ATTRIBUTE:[],REMOVE_ATTRIBUTE:[],TREE_OPS:[],NODE_VALUE:[]};const{SET_ATTRIBUTE:SET_ATTRIBUTE,REMOVE_ATTRIBUTE:REMOVE_ATTRIBUTE,TREE_OPS:TREE_OPS,NODE_VALUE:NODE_VALUE}=patches;const newNodeName=newTree.nodeName;const patchset={INSERT_BEFORE:[],REMOVE_CHILD:[],REPLACE_CHILD:[]};SyncTreeHookCache.forEach(fn=>{oldTree=specialCase||oldTree;let retVal=fn(oldTree,newTree,keysLookup,parentTree);if(retVal&&retVal===oldTree){shortCircuit=true}else if(retVal&&retVal!==newTree){newTree=retVal}});if(shortCircuit){return patches}const{INSERT_BEFORE:INSERT_BEFORE,REMOVE_CHILD:REMOVE_CHILD,REPLACE_CHILD:REPLACE_CHILD}=patchset;const isElement=newTree.nodeType===1;if(newTree.nodeName==="#text"){if(oldTree.nodeName!=="#text"){NODE_VALUE.push(newTree,newTree.nodeValue,null)}else if(!isEmpty&&oldTree.nodeValue!==newTree.nodeValue){NODE_VALUE.push(oldTree,newTree.nodeValue,oldTree.nodeValue);oldTree.nodeValue=newTree.nodeValue}return patches}if(isElement){const oldAttributes=isEmpty?empty:oldTree.attributes;const newAttributes=newTree.attributes;for(let key in newAttributes){const value=newAttributes[key];if(key in oldAttributes&&oldAttributes[key]===newAttributes[key]){continue}if(!isEmpty){oldAttributes[key]=value}SET_ATTRIBUTE.push(isEmpty?newTree:oldTree,key,value)}if(!isEmpty){for(let key in oldAttributes){if(key in newAttributes){continue}REMOVE_ATTRIBUTE.push(oldTree,key);delete oldAttributes[key]}}}if(process_default_0.env.NODE_ENV!=="production"){if(!isEmpty&&oldNodeName!==newNodeName&&!isFragment){throw new Error(`Sync failure, cannot compare ${newNodeName} with ${oldNodeName}`)}}const newChildNodes=newTree.childNodes;if(isEmpty){for(let i=0;i<newChildNodes.length;i++){sync_default_0(null,newChildNodes[i],patches,newTree)}return patches}const oldChildNodes=oldTree.childNodes;if(keysLookup.old.size||keysLookup.new.size){const values=keysLookup.old.values();for(let i=0;i<newChildNodes.length;i++){const oldChildNode=oldChildNodes[i];const newChildNode=newChildNodes[i];const newKey=newChildNode.key;if(!oldChildNode){INSERT_BEFORE.push(oldTree,newChildNode,null);oldChildNodes.push(newChildNode);sync_default_0(null,newChildNode,patches,newTree);continue}const oldKey=oldChildNode.key;const oldInNew=keysLookup.new.has(oldKey);const newInOld=keysLookup.old.has(newKey);if(!oldInNew&&!newInOld){REPLACE_CHILD.push(newChildNode,oldChildNode);oldChildNodes.splice(oldChildNodes.indexOf(oldChildNode),1,newChildNode);sync_default_0(null,newChildNode,patches,newTree);continue}else if(!oldInNew){REMOVE_CHILD.push(oldChildNode);oldChildNodes.splice(oldChildNodes.indexOf(oldChildNode),1);i=i-1;continue}if(newKey!==oldKey){let optimalNewNode=newChildNode;if(newKey&&newInOld){optimalNewNode=keysLookup.old.get(newKey);oldChildNodes.splice(oldChildNodes.indexOf(optimalNewNode),1)}else if(newKey){optimalNewNode=newChildNode;sync_default_0(null,newChildNode,patches,newTree)}INSERT_BEFORE.push(oldTree,optimalNewNode,oldChildNode);oldChildNodes.splice(i,0,optimalNewNode);continue}if(oldChildNode.nodeName!==newChildNode.nodeName){REPLACE_CHILD.push(newChildNode,oldChildNode);oldTree.childNodes[i]=newChildNode;sync_default_0(null,newChildNode,patches,newTree);continue}sync_default_0(oldChildNode,newChildNode,patches,newTree)}}else{for(let i=0;i<newChildNodes.length;i++){const oldChildNode=oldChildNodes&&oldChildNodes[i];const newChildNode=newChildNodes[i];if(!oldChildNode){INSERT_BEFORE.push(oldTree,newChildNode,null);if(oldChildNodes){oldChildNodes.push(newChildNode)}sync_default_0(oldChildNode,newChildNode,patches,oldTree);continue}if(oldChildNode.nodeName!==newChildNode.nodeName){REPLACE_CHILD.push(newChildNode,oldChildNode);oldTree.childNodes[i]=newChildNode;sync_default_0(null,newChildNode,patches,oldTree,oldTree.childNodes[i]);continue}sync_default_0(oldChildNode,newChildNode,patches,oldTree)}}if(oldChildNodes.length!==newChildNodes.length){for(let i=newChildNodes.length;i<oldChildNodes.length;i++){REMOVE_CHILD.push(oldChildNodes[i])}oldChildNodes.length=newChildNodes.length}if(INSERT_BEFORE.length||REMOVE_CHILD.length||REPLACE_CHILD.length){if(!INSERT_BEFORE.length){patchset.INSERT_BEFORE=null}if(!REMOVE_CHILD.length){patchset.REMOVE_CHILD=null}if(!REPLACE_CHILD.length){patchset.REPLACE_CHILD=null}TREE_OPS.push(patchset)}return patches};const sync_trees_default_0=function syncTrees(transaction){const{state:{measure:measure},oldTree:oldTree,newTree:newTree,domNode:domNode}=transaction;measure("sync trees");if(oldTree.nodeName!==newTree.nodeName&&newTree.nodeType!==11){if(!domNode.parentNode){throw new Error("Unable to replace top level node without a parent")}transaction.patches={TREE_OPS:[{REPLACE_CHILD:[newTree,oldTree]}],SET_ATTRIBUTE:[],REMOVE_ATTRIBUTE:[],NODE_VALUE:[]};unprotectVTree(transaction.oldTree);transaction.oldTree=transaction.state.oldTree=newTree;protectVTree(transaction.oldTree);StateCache.delete(domNode);StateCache.set(create_default_1(newTree),transaction.state)}else{transaction.patches=sync_default_0(oldTree,newTree)}measure("sync trees")};const stateNames=["attached","detached","replaced","attributeChanged","textChanged"];stateNames.forEach(stateName=>TransitionCache.set(stateName,new Set));function addTransitionState(stateName,callback){if(process_default_0.env.NODE_ENV!=="production"){if(!stateName||!stateNames.includes(stateName)){throw new Error(`Invalid state name '${stateName}'`)}if(!callback){throw new Error("Missing transition state callback")}}TransitionCache.get(stateName).add(callback)}function removeTransitionState(stateName,callback){if(process_default_0.env.NODE_ENV!=="production"){if(stateName&&!stateNames.includes(stateName)){throw new Error(`Invalid state name '${stateName}'`)}}if(!callback&&stateName){TransitionCache.get(stateName).clear()}else if(stateName&&callback){TransitionCache.get(stateName).delete(callback)}else{for(let i=0;i<stateNames.length;i++){TransitionCache.get(stateNames[i]).clear()}}}function runTransitions(setName,...args){const set=TransitionCache.get(setName);const promises=[];if(!set.size||setName!=="textChanged"&&args[0].nodeType===3){return promises}set.forEach(callback=>{const retVal=callback(...args);if(typeof retVal==="object"&&retVal.then){promises.push(retVal)}});if(setName==="attached"||setName==="detached"||setName==="replaced"){const element=args[0];[...element.childNodes].forEach(childNode=>{promises.push(...runTransitions(setName,childNode,...args.slice(1)))})}return promises}const blockText=new Set(["script","noscript","style","code","template"]);const blacklist=new Set;const whitelist=new Set;const removeAttribute=(domNode,name)=>{domNode.removeAttribute(name);const blacklistName=domNode.nodeName+"-"+name;if(whitelist.has(blacklistName)){domNode[name]=undefined}else if(!blacklist.has(blacklistName)){try{domNode[name]=undefined;whitelist.add(blacklistName)}catch(unhandledException){blacklist.add(blacklistName)}}};const patch_default_0=function patchNode(patches,state={}){const promises=[];const{TREE_OPS:TREE_OPS,NODE_VALUE:NODE_VALUE,SET_ATTRIBUTE:SET_ATTRIBUTE,REMOVE_ATTRIBUTE:REMOVE_ATTRIBUTE}=patches;const{isSVG:isSVG,ownerDocument:ownerDocument}=state;if(SET_ATTRIBUTE.length){for(let i=0;i<SET_ATTRIBUTE.length;i+=3){const vTree=SET_ATTRIBUTE[i];const _name=SET_ATTRIBUTE[i+1];const value=decode_entities_default_0(SET_ATTRIBUTE[i+2]);const domNode=create_default_1(vTree,ownerDocument,isSVG);const oldValue=domNode.getAttribute(_name);const newPromises=runTransitions("attributeChanged",domNode,_name,oldValue,value);const isObject=typeof value==="object";const isFunction=typeof value==="function";const name=_name.indexOf("on")===0?_name.toLowerCase():_name;const blacklistName=vTree.nodeName+"-"+name;if(!isObject&&!isFunction&&name){const noValue=value===null||value===undefined;if(whitelist.has(blacklistName)){domNode[name]=value}else if(!blacklist.has(blacklistName)){try{domNode[name]=value;whitelist.add(blacklistName)}catch(unhandledException){blacklist.add(blacklistName)}}domNode.setAttribute(name,noValue?"":value)}else if(isObject&&name==="style"){const keys=Object.keys(value);for(let i=0;i<keys.length;i++){domNode.style[keys[i]]=value[keys[i]]}}else if(typeof value!=="string"){if(whitelist.has(blacklistName)){domNode[name]=value}else if(!blacklist.has(blacklistName)){try{domNode[name]=value;whitelist.add(blacklistName)}catch(unhandledException){blacklist.add(blacklistName)}}}if(newPromises.length){promises.push(...newPromises)}}}if(REMOVE_ATTRIBUTE.length){for(let i=0;i<REMOVE_ATTRIBUTE.length;i+=2){const vTree=REMOVE_ATTRIBUTE[i];const name=REMOVE_ATTRIBUTE[i+1];const domNode=NodeCache.get(vTree);const attributeChanged=TransitionCache.get("attributeChanged");const oldValue=domNode.getAttribute(name);const newPromises=runTransitions("attributeChanged",domNode,name,oldValue,null);if(newPromises.length){Promise.all(newPromises).then(()=>removeAttribute(domNode,name));promises.push(...newPromises)}else{removeAttribute(domNode,name)}}}for(let i=0;i<TREE_OPS.length;i++){const{INSERT_BEFORE:INSERT_BEFORE,REMOVE_CHILD:REMOVE_CHILD,REPLACE_CHILD:REPLACE_CHILD}=TREE_OPS[i];if(INSERT_BEFORE&&INSERT_BEFORE.length){for(let i=0;i<INSERT_BEFORE.length;i+=3){const vTree=INSERT_BEFORE[i];const newTree=INSERT_BEFORE[i+1];const refTree=INSERT_BEFORE[i+2];const domNode=NodeCache.get(vTree);const refNode=refTree&&create_default_1(refTree,ownerDocument,isSVG);const attached=TransitionCache.get("attached");if(refTree){protectVTree(refTree)}const newNode=create_default_1(newTree,ownerDocument,isSVG);protectVTree(newTree);domNode.insertBefore(newNode,refNode);const attachedPromises=runTransitions("attached",newNode);promises.push(...attachedPromises)}}if(REMOVE_CHILD&&REMOVE_CHILD.length){for(let i=0;i<REMOVE_CHILD.length;i++){const vTree=REMOVE_CHILD[i];const domNode=NodeCache.get(vTree);const detached=TransitionCache.get("detached");const detachedPromises=runTransitions("detached",domNode);if(detachedPromises.length){Promise.all(detachedPromises).then(()=>{domNode.parentNode.removeChild(domNode);unprotectVTree(vTree)});promises.push(...detachedPromises)}else{domNode.parentNode.removeChild(domNode);unprotectVTree(vTree)}}}if(REPLACE_CHILD&&REPLACE_CHILD.length){for(let i=0;i<REPLACE_CHILD.length;i+=2){const newTree=REPLACE_CHILD[i];const oldTree=REPLACE_CHILD[i+1];const oldDomNode=NodeCache.get(oldTree);const newDomNode=create_default_1(newTree,ownerDocument,isSVG);const attached=TransitionCache.get("attached");const detached=TransitionCache.get("detached");const replaced=TransitionCache.get("replaced");oldDomNode.parentNode.insertBefore(newDomNode,oldDomNode);protectVTree(newTree);const attachedPromises=runTransitions("attached",newDomNode);const detachedPromises=runTransitions("detached",oldDomNode);const replacedPromises=runTransitions("replaced",oldDomNode,newDomNode);const allPromises=[...attachedPromises,...detachedPromises,...replacedPromises];if(allPromises.length){Promise.all(allPromises).then(()=>{oldDomNode.parentNode.replaceChild(newDomNode,oldDomNode);unprotectVTree(oldTree)});promises.push(...allPromises)}else{oldDomNode.parentNode.replaceChild(newDomNode,oldDomNode);unprotectVTree(oldTree)}}}}if(NODE_VALUE.length){for(let i=0;i<NODE_VALUE.length;i+=3){const vTree=NODE_VALUE[i];const nodeValue=NODE_VALUE[i+1];const oldValue=NODE_VALUE[i+2];const domNode=create_default_1(vTree);const textChanged=TransitionCache.get("textChanged");const textChangedPromises=runTransitions("textChanged",domNode,oldValue,nodeValue);const{parentNode:parentNode}=domNode;if(nodeValue.includes("&")){domNode.nodeValue=decode_entities_default_0(nodeValue)}else{domNode.nodeValue=nodeValue}if(parentNode&&blockText.has(parentNode.nodeName.toLowerCase())){parentNode.nodeValue=escape_default_0(decode_entities_default_0(nodeValue))}if(textChangedPromises.length){promises.push(...textChangedPromises)}}}return promises};const patch_node_default_0=function patch(transaction){const{domNode:domNode,state:state,state:{measure:measure},patches:patches}=transaction;const{promises:promises=[]}=transaction;const{nodeName:nodeName}=domNode;const namespaceURI=domNode.namespaceURI||"";state.isSVG=nodeName.toLowerCase()==="svg"||namespaceURI.includes("svg");state.ownerDocument=domNode.ownerDocument||document;measure("patch node");promises.push(...patch_default_0(patches,state));measure("patch node");transaction.promises=promises};const end_as_promise_default_0=function endAsPromise(transaction){const{promises:promises=[]}=transaction;if(promises.length){return transaction.promise=Promise.all(promises).then(()=>transaction.end())}return transaction.promise=Promise.resolve(transaction.end())};const defaultTasks=[schedule_default_0,should_update_default_0,reconcile_trees_default_0,sync_trees_default_0,patch_node_default_0,end_as_promise_default_0];const tasks={schedule:schedule_default_0,shouldUpdate:should_update_default_0,reconcileTrees:reconcile_trees_default_0,syncTrees:sync_trees_default_0,patchNode:patch_node_default_0,endAsPromise:end_as_promise_default_0};const transaction_default_0=class Transaction{static create(domNode,markup,options){return new Transaction(domNode,markup,options)}static flow(transaction,tasks){let retVal=transaction;for(let i=0;i<tasks.length;i++){if(transaction.aborted){return retVal}retVal=tasks[i](transaction);if(retVal!==undefined&&retVal!==transaction){return retVal}}}static assert(transaction){if(process_default_0.env.NODE_ENV!=="production"){if(typeof transaction.domNode!=="object"){throw new Error("Transaction requires a DOM Node mount point")}if(transaction.aborted&&transaction.completed){throw new Error("Transaction was previously aborted")}if(transaction.completed){throw new Error("Transaction was previously completed")}}}static invokeMiddleware(transaction){const{tasks:tasks}=transaction;MiddlewareCache.forEach(fn=>{const result=fn(transaction);if(result){tasks.push(result)}})}constructor(domNode,markup,options){this.domNode=domNode;this.markup=markup;this.options=options;this.state=StateCache.get(domNode)||{measure:make_measure_default_0(domNode,markup)};this.tasks=[].concat(options.tasks);this.endedCallbacks=new Set;StateCache.set(domNode,this.state)}start(){if(process_default_0.env.NODE_ENV!=="production"){Transaction.assert(this)}const{domNode:domNode,state:{measure:measure},tasks:tasks}=this;const takeLastTask=tasks.pop();this.aborted=false;Transaction.invokeMiddleware(this);measure("render");tasks.push(takeLastTask);return Transaction.flow(this,tasks)}abort(isReturn){const{state:state}=this;this.aborted=true;if(isReturn){return this.tasks[this.tasks.length-1](this)}}end(){const{state:state,domNode:domNode,options:options}=this;const{measure:measure}=state;const{inner:inner}=options;measure("finalize");this.completed=true;measure("finalize");measure("render");this.endedCallbacks.forEach(callback=>callback(this));this.endedCallbacks.clear();state.previousMarkup=domNode.outerHTML;state.isRendering=false;cleanMemory();return this}onceEnded(callback){this.endedCallbacks.add(callback)}};const inner_html_default_0=function innerHTML(domNode,markup="",options={}){options.inner=true;options.tasks=options.tasks||defaultTasks;return transaction_default_0.create(domNode,markup,options).start()};const outer_html_default_0=function outerHTML(domNode,markup="",options={}){options.inner=false;options.tasks=options.tasks||defaultTasks;return transaction_default_0.create(domNode,markup,options).start()};const release_default_0=function release(domNode){const state=StateCache.get(domNode);if(state&&state.oldTree){unprotectVTree(state.oldTree)}StateCache.delete(domNode);cleanMemory()};const use_default_0=function use(middleware){if(process_default_0.env.NODE_ENV!=="production"){if(typeof middleware!=="function"){throw new Error("Middleware must be a function")}}const{subscribe:subscribe,unsubscribe:unsubscribe,createTreeHook:createTreeHook,createNodeHook:createNodeHook,syncTreeHook:syncTreeHook,releaseHook:releaseHook}=middleware;MiddlewareCache.add(middleware);subscribe&&middleware.subscribe();createTreeHook&&CreateTreeHookCache.add(createTreeHook);createNodeHook&&CreateNodeHookCache.add(createNodeHook);syncTreeHook&&SyncTreeHookCache.add(syncTreeHook);releaseHook&&ReleaseHookCache.add(releaseHook);return()=>{MiddlewareCache.delete(middleware);unsubscribe&&unsubscribe();CreateTreeHookCache.delete(createTreeHook);CreateNodeHookCache.delete(createNodeHook);SyncTreeHookCache.delete(syncTreeHook);ReleaseHookCache.delete(releaseHook)}};const __VERSION__="1.0.0-beta.9";const VERSION=`${__VERSION__}-runtime`;const api={VERSION:VERSION,addTransitionState:addTransitionState,removeTransitionState:removeTransitionState,release:release_default_0,createTree:create_default_0,use:use_default_0,outerHTML:outer_html_default_0,innerHTML:inner_html_default_0,html:create_default_0,defaultTasks:defaultTasks};const Internals=assign(internals_default_0,api,{defaultTasks:defaultTasks,tasks:tasks,createNode:create_default_1,syncTree:create_default_0});api.Internals=Internals;if(typeof devTools==="function"){use_default_0(devTools(Internals));console.warn("diffHTML DevTools: Found and Activated...")}this.diffhtml=api;