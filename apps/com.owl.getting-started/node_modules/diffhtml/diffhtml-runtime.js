// Associates DOM Nodes with state objects.
const StateCache = new Map(); // Associates Virtual Tree Elements with DOM Nodes.

const NodeCache = new Map(); // Cache transition functions.

const TransitionCache = new Map(); // Caches all middleware. You cannot unset a middleware once it has been added.

const MiddlewareCache = new Set(); // Very specific caches used by middleware.

MiddlewareCache.CreateTreeHookCache = new Set();
MiddlewareCache.CreateNodeHookCache = new Set();
MiddlewareCache.SyncTreeHookCache = new Set();
MiddlewareCache.ReleaseHookCache = new Set();
const size = 10000;
const free = new Set();
const allocate = new Set();
const protect = new Set();

const shape = () => ({
  rawNodeName: '',
  nodeName: '',
  nodeValue: '',
  nodeType: 1,
  key: '',
  childNodes: [],
  attributes: {}
}); // Creates a pool to query new or reused values from.


const memory = {
  free,
  allocated: allocate,
  protected: protect
}; // Prime the free memory pool with VTrees.

for (let i = 0; i < size; i++) {
  free.add(shape());
} // Cache the values object, we'll refer to this iterator which is faster
// than calling it every single time. It gets replaced once exhausted.


let freeValues = free.values(); // Cache VTree objects in a pool which is used to get

const pool_default_0 = {
  size,
  memory,

  get() {
    const {
      value = shape(),
      done
    } = freeValues.next(); // This extra bit of work allows us to avoid calling `free.values()` every
    // single time an object is needed.

    if (done) {
      freeValues = free.values();
    }

    free.delete(value);
    allocate.add(value);
    return value;
  },

  protect(value) {
    allocate.delete(value);
    protect.add(value);
  },

  unprotect(value) {
    if (protect.has(value)) {
      protect.delete(value);
      free.add(value);
    }
  }

};
const {
  CreateTreeHookCache
} = MiddlewareCache;
const {
  isArray
} = Array;
const fragmentName = '#document-fragment';

const create_default_0 = function createTree(input, attributes, childNodes, ...rest) {
  // If no input was provided then we return an indication as such.
  if (!input) {
    return null;
  } // If the first argument is an array, we assume this is a DOM fragment and
  // the array are the childNodes.


  if (isArray(input)) {
    childNodes = [];

    for (let i = 0; i < input.length; i++) {
      const newTree = create_default_0(input[i]);

      if (!newTree) {
        continue;
      }

      const isFragment = newTree.nodeType === 11;

      if (typeof newTree.rawNodeName === 'string' && isFragment) {
        childNodes.push(...newTree.childNodes);
      } else {
        childNodes.push(newTree);
      }
    }

    return create_default_0(fragmentName, null, childNodes);
  }

  const isObject = typeof input === 'object'; // Crawl an HTML or SVG Element/Text Node etc. for attributes and children.

  if (input && isObject && 'parentNode' in input) {
    attributes = {};
    childNodes = []; // When working with a text node, simply save the nodeValue as the
    // initial value.

    if (input.nodeType === 3) {
      childNodes = input.nodeValue;
    } // Element types are the only kind of DOM node we care about attributes
    // from. Shadow DOM, Document Fragments, Text, Comment nodes, etc. can
    // ignore this.
    else if (input.nodeType === 1 && input.attributes.length) {
        attributes = {};

        for (let i = 0; i < input.attributes.length; i++) {
          const {
            name,
            value
          } = input.attributes[i]; // If the attribute's value is empty, seek out the property instead.

          if (value === '' && name in input) {
            attributes[name] = input[name];
            continue;
          }

          attributes[name] = value;
        }
      } // Get the child nodes from an Element or Fragment/Shadow Root.


    if (input.nodeType === 1 || input.nodeType === 11) {
      if (input.childNodes.length) {
        childNodes = [];

        for (let i = 0; i < input.childNodes.length; i++) {
          childNodes.push(create_default_0(input.childNodes[i]));
        }
      }
    }

    const vTree = create_default_0(input.nodeName, attributes, childNodes);
    NodeCache.set(vTree, input);
    return vTree;
  } // Assume any object value is a valid VTree object.


  if (isObject) {
    // Support JSX-like object shape.
    if ('children' in input && !('childNodes' in input)) {
      const nodeName = input.nodeName || input.elementName;
      return create_default_0(nodeName, input.attributes, input.children);
    }

    return input;
  } // Support JSX-style children being passed.


  if (rest.length) {
    childNodes = [childNodes, ...rest];
  } // Allocate a new VTree from the pool.


  const entry = pool_default_0.get();
  const isTextNode = input === '#text';
  const isString = typeof input === 'string';
  entry.key = '';
  entry.rawNodeName = input;
  entry.nodeName = isString ? input.toLowerCase() : '#document-fragment';
  entry.childNodes.length = 0;
  entry.nodeValue = '';
  entry.attributes = {};

  if (isTextNode) {
    const nodes = arguments.length === 2 ? attributes : childNodes;
    const nodeValue = isArray(nodes) ? nodes.join('') : nodes;
    entry.nodeType = 3;
    entry.nodeValue = String(nodeValue || '');
    return entry;
  }

  if (input === fragmentName || typeof input !== 'string') {
    entry.nodeType = 11;
  } else if (input === '#comment') {
    entry.nodeType = 8;
  } else {
    entry.nodeType = 1;
  }

  const useAttributes = isArray(attributes) || typeof attributes !== 'object';
  const nodes = useAttributes ? attributes : childNodes;
  const nodeArray = isArray(nodes) ? nodes : [nodes];

  if (nodes && nodeArray.length) {
    for (let i = 0; i < nodeArray.length; i++) {
      const newNode = nodeArray[i];
      const isNodeArray = isArray(newNode); // Merge in arrays.

      if (isNodeArray) {
        for (let i = 0; i < newNode.length; i++) {
          entry.childNodes.push(newNode[i]);
        }
      } // Skip over `null` nodes.
      else if (!newNode) {
          continue;
        } // Merge in fragments.
        else if (newNode.nodeType === 11 && typeof newNode.rawNodeName === 'string') {
            for (let i = 0; i < newNode.childNodes.length; i++) {
              entry.childNodes.push(newNode.childNodes[i]);
            }
          } // Assume objects are vTrees.
          else if (newNode && typeof newNode === 'object') {
              entry.childNodes.push(newNode);
            } // Cover generate cases where a user has indicated they do not want a
            // node from appearing.
            else if (newNode) {
                entry.childNodes.push(create_default_0('#text', null, newNode));
              }
    }
  }

  if (attributes && typeof attributes === 'object' && !isArray(attributes)) {
    entry.attributes = attributes;
  } // If is a script tag and has a src attribute, key off that.


  if (entry.nodeName === 'script' && entry.attributes.src) {
    entry.key = String(entry.attributes.src);
  } // Set the `key` prop if passed as an attr, overrides `script[src]`.


  if (entry.attributes && 'key' in entry.attributes) {
    entry.key = String(entry.attributes.key);
  }

  let vTree = entry;
  CreateTreeHookCache.forEach((fn, retVal) => {
    // Invoke all the `createNodeHook` functions passing along this transaction
    // as the only argument. These functions must return valid vTree values.
    if (retVal = fn(vTree)) {
      vTree = retVal;
    }
  });
  return vTree;
};

const __VERSION__ = '1.0.0-beta.9';
const {
  ReleaseHookCache
} = MiddlewareCache;
const {
  memory: memory_memory_1,
  protect: memory_protect_1,
  unprotect
} = pool_default_0;
/**
 * Ensures that an vTree is not recycled during a render cycle.
 *
 * @param vTree
 * @return vTree
 */

function protectVTree(vTree) {
  memory_protect_1(vTree);

  for (let i = 0; i < vTree.childNodes.length; i++) {
    protectVTree(vTree.childNodes[i]);
  }

  return vTree;
}
/**
 * Allows an vTree to be recycled during a render cycle.
 *
 * @param vTree
 * @return
 */


function unprotectVTree(vTree) {
  unprotect(vTree);

  if (ReleaseHookCache.size) {
    ReleaseHookCache.forEach(fn => fn(vTree));
  }

  for (let i = 0; i < vTree.childNodes.length; i++) {
    unprotectVTree(vTree.childNodes[i]);
  }

  return vTree;
}
/**
 * Moves all unprotected allocations back into available pool. This keeps
 * diffHTML in a consistent state after synchronizing.
 */


function cleanMemory(isBusy = false) {
  StateCache.forEach(state => isBusy = isBusy || state.isRendering); // Clean out unused elements, if we have any elements cached that no longer
  // have a backing VTree, we can safely remove them from the cache.

  if (!isBusy) {
    memory_memory_1.allocated.forEach(vTree => memory_memory_1.free.add(vTree));
    memory_memory_1.allocated.clear();
    NodeCache.forEach((node, vTree) => {
      if (!memory_memory_1.protected.has(vTree)) {
        NodeCache.delete(vTree);

        if (ReleaseHookCache.size) {
          ReleaseHookCache.forEach(fn => fn(vTree));
        }
      }
    });
  }
}

const marks = new Map();
const prefix = 'diffHTML';
const DIFF_PERF = 'diff_perf';
const hasSearch = typeof location !== 'undefined';
const hasArguments = typeof process !== 'undefined' && process.argv;

const nop = () => {};

const make_measure_default_0 = (domNode, vTree) => {
  // Check for these changes on every check.
  const wantsSearch = hasSearch && location.search.includes(DIFF_PERF);
  const wantsArguments = hasArguments && process.argv.includes(DIFF_PERF);
  const wantsPerfChecks = wantsSearch || wantsArguments; // If the user has not requested they want perf checks, return a nop
  // function.

  if (!wantsPerfChecks) {
    return nop;
  }

  return name => {
    // Use the Web Component name if it's available.
    if (domNode && domNode.host) {
      name = `${domNode.host.constructor.name} ${name}`;
    } else if (typeof vTree.rawNodeName === 'function') {
      name = `${vTree.rawNodeName.name} ${name}`;
    }

    const endName = `${name}-end`;

    if (!marks.has(name)) {
      marks.set(name, performance.now());
      performance.mark(name);
    } else {
      const totalMs = (performance.now() - marks.get(name)).toFixed(3);
      marks.delete(name);
      performance.mark(endName);
      performance.measure(`${prefix} ${name} (${totalMs}ms)`, name, endName);
    }
  };
};

const process_default_0 = typeof process !== 'undefined' ? process : {
  env: {
    NODE_ENV: 'development'
  }
};

const should_update_default_0 = function shouldUpdate(transaction) {
  const {
    domNode,
    markup,
    state,
    state: {
      measure
    },
    options
  } = transaction;
  const prop = options.inner ? 'innerHTML' : 'outerHTML';
  measure('should update'); // If the contents haven't changed, abort the flow. Only support this if
  // the new markup is a string, otherwise it's possible for our object

  if (typeof markup === 'string' && domNode[prop] === markup) {
    return transaction.abort(true);
  } else if (typeof markup === 'string') {
    state.markup = markup;
  }

  measure('should update');
};

// resolves when completed. If you want to make diffHTML return streams or
// callbacks replace this function.
const end_as_promise_default_0 = function endAsPromise(transaction) {
  const {
    promises = []
  } = transaction; // Operate synchronously unless opted into a Promise-chain. Doesn't matter
  // if they are actually Promises or not, since they will all resolve
  // eventually with `Promise.all`.

  if (promises.length) {
    return transaction.promise = Promise.all(promises).then(() => transaction.end());
  } // Pass off the remaining middleware to allow users to dive into the
  // transaction completed lifecycle event.


  return transaction.promise = Promise.resolve(transaction.end());
};

/**
 * If diffHTML is rendering anywhere asynchronously, we need to wait until it
 * completes before this render can be executed. This sets up the next
 * buffer, if necessary, which serves as a Boolean determination later to
 * `bufferSet`.
 *
 * @param {Object} nextTransaction - The Transaction instance to schedule
 * @return {Boolean} - Value used to terminate a transaction render flow
 */
const schedule_default_0 = function schedule(transaction) {
  // The state is a global store which is shared by all like-transactions.
  let {
    state
  } = transaction;
  const {
    isRendering,
    activeTransaction,
    nextTransaction
  } = state; // If there is an in-flight transaction render happening, push this
  // transaction into a queue.

  if (isRendering) {
    const {
      tasks
    } = transaction;
    const chainTransaction = nextTransaction || activeTransaction; // Pave over the `nextTransaction` to chain off the previous.

    state.nextTransaction = transaction; // Abort the remaining tasks (but do not signal completion).

    transaction.abort();
    const promise = chainTransaction.promise || Promise.resolve();
    return transaction.promise = promise.then(() => {
      transaction.aborted = false;
      return transaction_default_0.flow(transaction, tasks.slice(1));
    });
  } // Indicate we are now rendering a transaction for this DOM Node.


  state.isRendering = true;
  state.activeTransaction = transaction;
};

const reconcile_trees_default_0 = function reconcileTrees(transaction) {
  const {
    state,
    domNode,
    markup,
    options
  } = transaction;
  const {
    previousMarkup
  } = state;
  const {
    inner
  } = options;
  const {
    outerHTML
  } = domNode; // We rebuild the tree whenever the DOM Node changes, including the first
  // time we patch a DOM Node.

  if (previousMarkup !== outerHTML || !state.oldTree || !outerHTML) {
    if (state.oldTree) {
      unprotectVTree(state.oldTree);
    }

    state.oldTree = create_default_0(domNode);
    NodeCache.set(state.oldTree, domNode);
    protectVTree(state.oldTree);
  } // Associate the old tree with this brand new transaction.


  transaction.oldTree = state.oldTree; // If we are in a render transaction where no markup was previously parsed
  // then reconcile trees will attempt to create a tree based on the incoming
  // markup (JSX/html/etc).

  if (!transaction.newTree) {
    transaction.newTree = create_default_0(markup);
  } // If we are diffing only the parent's childNodes, then adjust the newTree to
  // be a replica of the oldTree except with the childNodes changed.


  if (inner) {
    const {
      oldTree,
      newTree
    } = transaction;
    const {
      rawNodeName,
      nodeName,
      attributes
    } = oldTree;
    const isUnknown = typeof newTree.rawNodeName !== 'string';
    const isFragment = newTree.nodeType === 11;
    const children = isFragment && !isUnknown ? newTree.childNodes : newTree;
    transaction.newTree = create_default_0(nodeName, attributes, children);
  }
};

const {
  CreateNodeHookCache
} = MiddlewareCache;
const namespace = 'http://www.w3.org/2000/svg';
/**
 * Takes in a Virtual Tree Element (VTree) and creates a DOM Node from it.
 * Sets the node into the Node cache. If this VTree already has an
 * associated node, it will reuse that.
 *
 * @param {Object} - A Virtual Tree Element or VTree-like element
 * @param {Object} - Document to create Nodes in
 * @param {Boolean} - Is their a root SVG element?
 * @return {Object} - A DOM Node matching the vTree
 */

const create_default_1 = function createNode(vTree, ownerDocument = document, isSVG) {
  if (process_default_0.env.NODE_ENV !== 'production') {
    if (!vTree) {
      throw new Error('Missing VTree when trying to create DOM Node');
    }
  }

  const existingNode = NodeCache.get(vTree); // If the DOM Node was already created, reuse the existing node.

  if (existingNode) {
    if (existingNode.nodeName.toLowerCase() !== vTree.nodeName) {
      throw new Error('Shit is wrong');
    }

    return existingNode;
  }

  const {
    nodeName,
    rawNodeName = nodeName,
    childNodes = []
  } = vTree;
  isSVG = isSVG || nodeName === 'svg'; // Will vary based on the properties of the VTree.

  let domNode = null;
  CreateNodeHookCache.forEach((fn, retVal) => {
    // Invoke all the `createNodeHook` functions passing along the vTree as the
    // only argument. These functions must return a valid DOM Node value.
    if (retVal = fn(vTree)) {
      domNode = retVal;
    }
  });

  if (!domNode) {
    // Create empty text elements. They will get filled in during the patch
    // process.
    if (nodeName === '#text') {
      domNode = ownerDocument.createTextNode(vTree.nodeValue);
    } // Support dynamically creating document fragments.
    else if (nodeName === '#document-fragment') {
        domNode = ownerDocument.createDocumentFragment();
      } // Support SVG.
      else if (isSVG) {
          domNode = ownerDocument.createElementNS(namespace, rawNodeName);
        } // If not a Text or SVG Node, then create with the standard method.
        else {
            domNode = ownerDocument.createElement(rawNodeName);
          }
  } // Add to the domNodes cache.


  NodeCache.set(vTree, domNode); // Append all the children into the domNode, making sure to run them
  // through this `createNode` function as well.

  for (let i = 0; i < childNodes.length; i++) {
    domNode.appendChild(create_default_1(childNodes[i], ownerDocument, isSVG));
  }

  return domNode;
};

const {
  SyncTreeHookCache
} = MiddlewareCache;
const empty = {};
const keyNames = ['old', 'new']; // Compares how the new state should look to the old state and mutates it,
// while recording the changes along the way.

const sync_default_0 = function syncTree(oldTree, newTree, patches, parentTree, specialCase) {
  if (!oldTree) oldTree = empty;
  if (!newTree) newTree = empty;
  const oldNodeName = oldTree.nodeName;
  const isFragment = newTree.nodeType === 11;
  const isEmpty = oldTree === empty;
  const keysLookup = {
    old: new Map(),
    new: new Map()
  };

  if (process_default_0.env.NODE_ENV !== 'production') {
    if (newTree === empty) {
      throw new Error('Missing new Virtual Tree to sync changes from');
    } // FIXME: Causes issues w/ React, we need to normalize at a higher level.


    if (!isEmpty && oldNodeName !== newTree.nodeName && !isFragment) {
      throw new Error(`Sync failure, cannot compare ${newTree.nodeName} with ${oldNodeName}`);
    }
  } // Reduce duplicate logic by condensing old and new operations in a loop.


  for (let i = 0; i < keyNames.length; i++) {
    const keyName = keyNames[i];
    const map = keysLookup[keyName];
    const vTree = arguments[i];
    const nodes = vTree && vTree.childNodes;

    if (nodes && nodes.length) {
      for (let i = 0; i < nodes.length; i++) {
        const vTree = nodes[i];

        if (vTree.key) {
          if (process_default_0.env.NODE_ENV !== 'production') {
            if (map.has(vTree.key)) {
              throw new Error(`Key: ${vTree.key} cannot be duplicated`);
            }
          }

          map.set(vTree.key, vTree);
        }
      }
    }
  }

  let shortCircuit = false; // Create new arrays for patches or use existing from a recursive call.

  patches = patches || {
    SET_ATTRIBUTE: [],
    REMOVE_ATTRIBUTE: [],
    TREE_OPS: [],
    NODE_VALUE: []
  };
  const {
    SET_ATTRIBUTE,
    REMOVE_ATTRIBUTE,
    TREE_OPS,
    NODE_VALUE
  } = patches;
  const newNodeName = newTree.nodeName; // Build up a patchset object to use for tree operations.

  const patchset = {
    INSERT_BEFORE: [],
    REMOVE_CHILD: [],
    REPLACE_CHILD: []
  }; // Invoke any middleware hooks, allow the middleware to replace the
  // `newTree`. Pass along the `keysLookup` object so that middleware can make
  // smart decisions when dealing with keys.

  SyncTreeHookCache.forEach(fn => {
    oldTree = specialCase || oldTree; // Call the user provided middleware function for a single root node. Allow
    // the consumer to specify a return value of a different VTree (useful for
    // components).

    let retVal = fn(oldTree, newTree, keysLookup, parentTree); // If the value returned matches the original element, then short circuit
    // and do not dig further.

    if (retVal && retVal === oldTree) {
      shortCircuit = true;
    } // If the consumer returned a value and it doesn't equal the existing tree,
    // then splice it into the parent (if it exists) and run a sync.
    else if (retVal && retVal !== newTree) {
        // Synchronize this new tree.
        newTree = retVal;
      }
  });

  if (shortCircuit) {
    return patches;
  } // USED: INSERT_BEFORE: 3x, REMOVE_CHILD: 1x, REPLACE_CHILD: 3x.


  const {
    INSERT_BEFORE,
    REMOVE_CHILD,
    REPLACE_CHILD
  } = patchset;
  const isElement = newTree.nodeType === 1; // Text nodes are low level and frequently change, so this path is accounted
  // for first.

  if (newTree.nodeName === '#text') {
    // If there was no previous element to compare to, simply set the value
    // on the new node.
    if (oldTree.nodeName !== '#text') {
      NODE_VALUE.push(newTree, newTree.nodeValue, null);
    } // If both VTrees are text nodes and the values are different, change the
    // `Element#nodeValue`.
    else if (!isEmpty && oldTree.nodeValue !== newTree.nodeValue) {
        NODE_VALUE.push(oldTree, newTree.nodeValue, oldTree.nodeValue);
        oldTree.nodeValue = newTree.nodeValue;
      }

    return patches;
  } // Seek out attribute changes first, but only from element Nodes.


  if (isElement) {
    const oldAttributes = isEmpty ? empty : oldTree.attributes;
    const newAttributes = newTree.attributes; // Search for sets and changes.

    for (let key in newAttributes) {
      const value = newAttributes[key];

      if (key in oldAttributes && oldAttributes[key] === newAttributes[key]) {
        continue;
      }

      if (!isEmpty) {
        oldAttributes[key] = value;
      }

      SET_ATTRIBUTE.push(isEmpty ? newTree : oldTree, key, value);
    } // Search for removals.


    if (!isEmpty) {
      for (let key in oldAttributes) {
        if (key in newAttributes) {
          continue;
        }

        REMOVE_ATTRIBUTE.push(oldTree, key);
        delete oldAttributes[key];
      }
    }
  } // If we somehow end up comparing two totally different kinds of elements,
  // we'll want to raise an error to let the user know something is wrong.
  // FIXME


  if (process_default_0.env.NODE_ENV !== 'production') {
    if (!isEmpty && oldNodeName !== newNodeName && !isFragment) {
      throw new Error(`Sync failure, cannot compare ${newNodeName} with ${oldNodeName}`);
    }
  }

  const newChildNodes = newTree.childNodes; // Scan all childNodes for attribute changes.

  if (isEmpty) {
    // Do a single pass over the new child nodes.
    for (let i = 0; i < newChildNodes.length; i++) {
      sync_default_0(null, newChildNodes[i], patches, newTree);
    }

    return patches;
  }

  const oldChildNodes = oldTree.childNodes; // If we are working with keys, we can follow an optimized path.

  if (keysLookup.old.size || keysLookup.new.size) {
    const values = keysLookup.old.values(); // Do a single pass over the new child nodes.

    for (let i = 0; i < newChildNodes.length; i++) {
      const oldChildNode = oldChildNodes[i];
      const newChildNode = newChildNodes[i];
      const newKey = newChildNode.key; // If there is no old element to compare to, this is a simple addition.

      if (!oldChildNode) {
        INSERT_BEFORE.push(oldTree, newChildNode, null);
        oldChildNodes.push(newChildNode);
        sync_default_0(null, newChildNode, patches, newTree);
        continue;
      }

      const oldKey = oldChildNode.key;
      const oldInNew = keysLookup.new.has(oldKey);
      const newInOld = keysLookup.old.has(newKey); // Remove the old Node and insert the new node (aka replace).

      if (!oldInNew && !newInOld) {
        REPLACE_CHILD.push(newChildNode, oldChildNode);
        oldChildNodes.splice(oldChildNodes.indexOf(oldChildNode), 1, newChildNode);
        sync_default_0(null, newChildNode, patches, newTree);
        continue;
      } // Remove the old node instead of replacing.
      else if (!oldInNew) {
          REMOVE_CHILD.push(oldChildNode);
          oldChildNodes.splice(oldChildNodes.indexOf(oldChildNode), 1);
          i = i - 1;
          continue;
        } // If there is a key set for this new element, use that to figure out
      // which element to use.


      if (newKey !== oldKey) {
        let optimalNewNode = newChildNode; // Prefer existing to new and remove from old position.

        if (newKey && newInOld) {
          optimalNewNode = keysLookup.old.get(newKey);
          oldChildNodes.splice(oldChildNodes.indexOf(optimalNewNode), 1);
        } else if (newKey) {
          optimalNewNode = newChildNode; // Find attribute changes for this Node.

          sync_default_0(null, newChildNode, patches, newTree);
        }

        INSERT_BEFORE.push(oldTree, optimalNewNode, oldChildNode);
        oldChildNodes.splice(i, 0, optimalNewNode);
        continue;
      } // If the element we're replacing is totally different from the previous
      // replace the entire element, don't bother investigating children.


      if (oldChildNode.nodeName !== newChildNode.nodeName) {
        REPLACE_CHILD.push(newChildNode, oldChildNode);
        oldTree.childNodes[i] = newChildNode;
        sync_default_0(null, newChildNode, patches, newTree);
        continue;
      }

      sync_default_0(oldChildNode, newChildNode, patches, newTree);
    }
  } // No keys used on this level, so we will do easier transformations.
  else {
      // Do a single pass over the new child nodes.
      for (let i = 0; i < newChildNodes.length; i++) {
        const oldChildNode = oldChildNodes && oldChildNodes[i];
        const newChildNode = newChildNodes[i]; // If there is no old element to compare to, this is a simple addition.

        if (!oldChildNode) {
          INSERT_BEFORE.push(oldTree, newChildNode, null);

          if (oldChildNodes) {
            oldChildNodes.push(newChildNode);
          }

          sync_default_0(oldChildNode, newChildNode, patches, oldTree);
          continue;
        } // If the element we're replacing is totally different from the previous
        // replace the entire element, don't bother investigating children.


        if (oldChildNode.nodeName !== newChildNode.nodeName) {
          REPLACE_CHILD.push(newChildNode, oldChildNode); // FIXME Calling this out specifically as a special case since we
          // have conflicting requirements between synchronization and how
          // components handle reconcilation. We basically don't want to dig
          // deeper into the component at the diffHTML level, but want to let
          // the middleware have access to the old child.
          //
          // This avoids sync semantics of oldTree/newTree while still providing
          // the oldTree to middleware.

          oldTree.childNodes[i] = newChildNode;
          sync_default_0(null, newChildNode, patches, oldTree, oldTree.childNodes[i]);
          continue;
        }

        sync_default_0(oldChildNode, newChildNode, patches, oldTree);
      }
    } // We've reconciled new changes, so we can remove any old nodes and adjust
  // lengths to be equal.


  if (oldChildNodes.length !== newChildNodes.length) {
    for (let i = newChildNodes.length; i < oldChildNodes.length; i++) {
      REMOVE_CHILD.push(oldChildNodes[i]);
    }

    oldChildNodes.length = newChildNodes.length;
  } // We want to look if anything has changed, if nothing has we won't add it to
  // the patchset.


  if (INSERT_BEFORE.length || REMOVE_CHILD.length || REPLACE_CHILD.length) {
    // Null out the empty arrays.
    if (!INSERT_BEFORE.length) {
      patchset.INSERT_BEFORE = null;
    }

    if (!REMOVE_CHILD.length) {
      patchset.REMOVE_CHILD = null;
    }

    if (!REPLACE_CHILD.length) {
      patchset.REPLACE_CHILD = null;
    }

    TREE_OPS.push(patchset);
  }

  return patches;
};

const sync_trees_default_0 = function syncTrees(transaction) {
  const {
    state: {
      measure
    },
    oldTree,
    newTree,
    domNode
  } = transaction;
  measure('sync trees'); // Do a global replace of the element, unable to do this at a lower level.
  // Ignore this for document fragments, they don't appear in the DOM and we
  // treat them as transparent containers.

  if (oldTree.nodeName !== newTree.nodeName && newTree.nodeType !== 11) {
    // If there is no `parentNode` for the replace operation, we will need to
    // throw an error and prevent the `StateCache` from being updated.
    if (!domNode.parentNode) {
      throw new Error('Unable to replace top level node without a parent');
    }

    transaction.patches = {
      TREE_OPS: [{
        REPLACE_CHILD: [newTree, oldTree]
      }],
      SET_ATTRIBUTE: [],
      REMOVE_ATTRIBUTE: [],
      NODE_VALUE: []
    };
    unprotectVTree(transaction.oldTree);
    transaction.oldTree = transaction.state.oldTree = newTree;
    protectVTree(transaction.oldTree); // Update the StateCache since we are changing the top level element.

    StateCache.delete(domNode);
    StateCache.set(create_default_1(newTree), transaction.state);
  } // Otherwise only diff the children.
  else {
      transaction.patches = sync_default_0(oldTree, newTree);
    }

  measure('sync trees');
};

const stateNames = ['attached', 'detached', 'replaced', 'attributeChanged', 'textChanged']; // Sets up the states up so we can add and remove events from the sets.

stateNames.forEach(stateName => TransitionCache.set(stateName, new Set()));

function transition_addTransitionState_1(stateName, callback) {
  if (process_default_0.env.NODE_ENV !== 'production') {
    if (!stateName || !stateNames.includes(stateName)) {
      throw new Error(`Invalid state name '${stateName}'`);
    }

    if (!callback) {
      throw new Error('Missing transition state callback');
    }
  }

  TransitionCache.get(stateName).add(callback);
}

function transition_removeTransitionState_1(stateName, callback) {
  if (process_default_0.env.NODE_ENV !== 'production') {
    // Only validate the stateName if the caller provides one.
    if (stateName && !stateNames.includes(stateName)) {
      throw new Error(`Invalid state name '${stateName}'`);
    }
  }

  if (!callback && stateName) {
    TransitionCache.get(stateName).clear();
  } else if (stateName && callback) {
      TransitionCache.get(stateName).delete(callback);
    } // Remove all callbacks.
    else {
        for (let i = 0; i < stateNames.length; i++) {
          TransitionCache.get(stateNames[i]).clear();
        }
      }
}

function runTransitions(setName, ...args) {
  const set = TransitionCache.get(setName);
  const promises = []; // Ignore empty sets and ignore text nodes.

  if (!set.size || setName !== 'textChanged' && args[0].nodeType === 3) {
    return promises;
  } // Run each transition callback, if on the attached/detached.


  set.forEach(callback => {
    const retVal = callback(...args); // Is a "thennable" object or native Promise.

    if (typeof retVal === 'object' && retVal.then) {
      promises.push(retVal);
    }
  });

  if (setName === 'attached' || setName === 'detached' || setName === 'replaced') {
    const element = args[0];
    [...element.childNodes].forEach(childNode => {
      promises.push(...runTransitions(setName, childNode, ...args.slice(1)));
    });
  }

  return promises;
}

const g = typeof global === 'object' ? global : window;
const element = g.document ? document.createElement('div') : null;
/**
 * Decodes HTML strings.
 *
 * @see http://stackoverflow.com/a/5796718
 * @param string
 * @return unescaped HTML
 */

const decode_entities_default_0 = function decodeEntities(string) {
  // If there are no HTML entities, we can safely pass the string through.
  if (!element || !string || !string.indexOf || !string.includes('&')) {
    return string;
  }

  element.innerHTML = string;
  return element.textContent;
};

const escape_default_0 = function escape(unescaped) {
  return unescaped.replace(/[&<>]/g, match => `&#${match.charCodeAt(0)};`);
};

const blockText = new Set(['script', 'noscript', 'style', 'code', 'template']);
const blacklist = new Set();
const whitelist = new Set();

const removeAttribute = (domNode, name) => {
  domNode.removeAttribute(name); // Runtime checking if the property can be set.

  const blacklistName = domNode.nodeName + '-' + name;

  if (whitelist.has(blacklistName)) {
    domNode[name] = void 0;
  } else if (!blacklist.has(blacklistName)) {
    try {
      domNode[name] = void 0;
      whitelist.add(blacklistName);
    } catch (unhandledException) {
      blacklist.add(blacklistName);
    }
  }
};

const patch_default_0 = function patchNode(patches, state = {}) {
  const promises = [];
  const {
    TREE_OPS,
    NODE_VALUE,
    SET_ATTRIBUTE,
    REMOVE_ATTRIBUTE
  } = patches;
  const {
    isSVG,
    ownerDocument
  } = state; // Set attributes.

  if (SET_ATTRIBUTE.length) {
    for (let i = 0; i < SET_ATTRIBUTE.length; i += 3) {
      const vTree = SET_ATTRIBUTE[i];
      const _name = SET_ATTRIBUTE[i + 1];
      const value = decode_entities_default_0(SET_ATTRIBUTE[i + 2]);
      const domNode = create_default_1(vTree, ownerDocument, isSVG);
      const oldValue = domNode.getAttribute(_name);
      const newPromises = runTransitions('attributeChanged', domNode, _name, oldValue, value); // Triggered either synchronously or asynchronously depending on if a
      // transition was invoked.

      const isObject = typeof value === 'object';
      const isFunction = typeof value === 'function'; // Events must be lowercased otherwise they will not be set correctly.

      const name = _name.indexOf('on') === 0 ? _name.toLowerCase() : _name;
      const blacklistName = vTree.nodeName + '-' + name; // Normal attribute value.

      if (!isObject && !isFunction && name) {
        const noValue = value === null || value === void 0;

        if (whitelist.has(blacklistName)) {
          domNode[name] = value;
        } else if (!blacklist.has(blacklistName)) {
          try {
            domNode[name] = value;
            whitelist.add(blacklistName);
          } catch (unhandledException) {
            blacklist.add(blacklistName);
          }
        } // Set the actual attribute, this will ensure attributes like
        // `autofocus` aren't reset by the property call above.


        domNode.setAttribute(name, noValue ? '' : value);
      } // Support patching an object representation of the style object.
      else if (isObject && name === 'style') {
          const keys = Object.keys(value);

          for (let i = 0; i < keys.length; i++) {
            domNode.style[keys[i]] = value[keys[i]];
          }
        } else if (typeof value !== 'string') {
          // Since this is a property value it gets set directly on the node.
          if (whitelist.has(blacklistName)) {
            domNode[name] = value;
          } else if (!blacklist.has(blacklistName)) {
            try {
              domNode[name] = value;
              whitelist.add(blacklistName);
            } catch (unhandledException) {
              blacklist.add(blacklistName);
            }
          }
        }

      if (newPromises.length) {
        promises.push(...newPromises);
      }
    }
  } // Remove attributes.


  if (REMOVE_ATTRIBUTE.length) {
    for (let i = 0; i < REMOVE_ATTRIBUTE.length; i += 2) {
      const vTree = REMOVE_ATTRIBUTE[i];
      const name = REMOVE_ATTRIBUTE[i + 1];
      const domNode = NodeCache.get(vTree);
      const attributeChanged = TransitionCache.get('attributeChanged');
      const oldValue = domNode.getAttribute(name);
      const newPromises = runTransitions('attributeChanged', domNode, name, oldValue, null);

      if (newPromises.length) {
        Promise.all(newPromises).then(() => removeAttribute(domNode, name));
        promises.push(...newPromises);
      } else {
        removeAttribute(domNode, name);
      }
    }
  } // DOM Tree.


  for (let i = 0; i < TREE_OPS.length; i++) {
    const {
      INSERT_BEFORE,
      REMOVE_CHILD,
      REPLACE_CHILD
    } = TREE_OPS[i]; // Insert/append elements.

    if (INSERT_BEFORE && INSERT_BEFORE.length) {
      for (let i = 0; i < INSERT_BEFORE.length; i += 3) {
        const vTree = INSERT_BEFORE[i];
        const newTree = INSERT_BEFORE[i + 1];
        const refTree = INSERT_BEFORE[i + 2];
        const domNode = NodeCache.get(vTree);
        const refNode = refTree && create_default_1(refTree, ownerDocument, isSVG);
        const attached = TransitionCache.get('attached');

        if (refTree) {
          protectVTree(refTree);
        }

        const newNode = create_default_1(newTree, ownerDocument, isSVG);
        protectVTree(newTree); // If refNode is `null` then it will simply append like `appendChild`.

        domNode.insertBefore(newNode, refNode);
        const attachedPromises = runTransitions('attached', newNode);
        promises.push(...attachedPromises);
      }
    } // Remove elements.


    if (REMOVE_CHILD && REMOVE_CHILD.length) {
      for (let i = 0; i < REMOVE_CHILD.length; i++) {
        const vTree = REMOVE_CHILD[i];
        const domNode = NodeCache.get(vTree);
        const detached = TransitionCache.get('detached');
        const detachedPromises = runTransitions('detached', domNode);

        if (detachedPromises.length) {
          Promise.all(detachedPromises).then(() => {
            domNode.parentNode.removeChild(domNode);
            unprotectVTree(vTree);
          });
          promises.push(...detachedPromises);
        } else {
          domNode.parentNode.removeChild(domNode);
          unprotectVTree(vTree);
        }
      }
    } // Replace elements.


    if (REPLACE_CHILD && REPLACE_CHILD.length) {
      for (let i = 0; i < REPLACE_CHILD.length; i += 2) {
        const newTree = REPLACE_CHILD[i];
        const oldTree = REPLACE_CHILD[i + 1];
        const oldDomNode = NodeCache.get(oldTree);
        const newDomNode = create_default_1(newTree, ownerDocument, isSVG);
        const attached = TransitionCache.get('attached');
        const detached = TransitionCache.get('detached');
        const replaced = TransitionCache.get('replaced'); // Always insert before to allow the element to transition.

        oldDomNode.parentNode.insertBefore(newDomNode, oldDomNode);
        protectVTree(newTree);
        const attachedPromises = runTransitions('attached', newDomNode);
        const detachedPromises = runTransitions('detached', oldDomNode);
        const replacedPromises = runTransitions('replaced', oldDomNode, newDomNode);
        const allPromises = [...attachedPromises, ...detachedPromises, ...replacedPromises];

        if (allPromises.length) {
          Promise.all(allPromises).then(() => {
            oldDomNode.parentNode.replaceChild(newDomNode, oldDomNode);
            unprotectVTree(oldTree);
          });
          promises.push(...allPromises);
        } else {
          oldDomNode.parentNode.replaceChild(newDomNode, oldDomNode);
          unprotectVTree(oldTree);
        }
      }
    }
  } // Change all nodeValues.


  if (NODE_VALUE.length) {
    for (let i = 0; i < NODE_VALUE.length; i += 3) {
      const vTree = NODE_VALUE[i];
      const nodeValue = NODE_VALUE[i + 1];
      const oldValue = NODE_VALUE[i + 2];
      const domNode = create_default_1(vTree);
      const textChanged = TransitionCache.get('textChanged');
      const textChangedPromises = runTransitions('textChanged', domNode, oldValue, nodeValue);
      const {
        parentNode
      } = domNode;

      if (nodeValue.includes('&')) {
        domNode.nodeValue = decode_entities_default_0(nodeValue);
      } else {
        domNode.nodeValue = nodeValue;
      }

      if (parentNode && blockText.has(parentNode.nodeName.toLowerCase())) {
        parentNode.nodeValue = escape_default_0(decode_entities_default_0(nodeValue));
      }

      if (textChangedPromises.length) {
        promises.push(...textChangedPromises);
      }
    }
  }

  return promises;
};

/**
 * Processes a set of patches onto a tracked DOM Node.
 *
 * @param {Object} node - DOM Node to process patchs on
 * @param {Array} patches - Contains patch objects
 */
const patch_node_default_0 = function patch(transaction) {
  const {
    domNode,
    state,
    state: {
      measure
    },
    patches
  } = transaction;
  const {
    promises = []
  } = transaction;
  const {
    nodeName
  } = domNode;
  const namespaceURI = domNode.namespaceURI || '';
  state.isSVG = nodeName.toLowerCase() === 'svg' || namespaceURI.includes('svg');
  state.ownerDocument = domNode.ownerDocument || document;
  measure('patch node');
  promises.push(...patch_default_0(patches, state));
  measure('patch node');
  transaction.promises = promises;
};

const defaultTasks = [schedule_default_0, should_update_default_0, reconcile_trees_default_0, sync_trees_default_0, patch_node_default_0, end_as_promise_default_0];
const tasks = {
  schedule: schedule_default_0,
  shouldUpdate: should_update_default_0,
  reconcileTrees: reconcile_trees_default_0,
  syncTrees: sync_trees_default_0,
  patchNode: patch_node_default_0,
  endAsPromise: end_as_promise_default_0
};
const transaction_default_0 = class Transaction {
  static create(domNode, markup, options) {
    return new Transaction(domNode, markup, options);
  }

  static flow(transaction, tasks) {
    let retVal = transaction; // Execute each "task" serially, passing the transaction as a baton that
    // can be used to share state across the tasks.

    for (let i = 0; i < tasks.length; i++) {
      // If aborted, don't execute any more tasks.
      if (transaction.aborted) {
        return retVal;
      } // Run the task.


      retVal = tasks[i](transaction); // The last `returnValue` is what gets sent to the consumer. This
      // mechanism is crucial for the `abort`, if you want to modify the "flow"
      // that's fine, but you must ensure that your last task provides a
      // mechanism to know when the transaction completes. Something like
      // callbacks or a Promise.

      if (retVal !== void 0 && retVal !== transaction) {
        return retVal;
      }
    }
  }

  static assert(transaction) {
    if (process_default_0.env.NODE_ENV !== 'production') {
      if (typeof transaction.domNode !== 'object') {
        throw new Error('Transaction requires a DOM Node mount point');
      }

      if (transaction.aborted && transaction.completed) {
        throw new Error('Transaction was previously aborted');
      }

      if (transaction.completed) {
        throw new Error('Transaction was previously completed');
      }
    }
  }

  static invokeMiddleware(transaction) {
    const {
      tasks
    } = transaction;
    MiddlewareCache.forEach(fn => {
      // Invoke all the middleware passing along this transaction as the only
      // to the transaction task flow.
      const result = fn(transaction);

      if (result) {
        tasks.push(result);
      }
    });
  }

  constructor(domNode, markup, options) {
    this.domNode = domNode;
    this.markup = markup;
    this.options = options;
    this.state = StateCache.get(domNode) || {
      measure: make_measure_default_0(domNode, markup)
    };
    this.tasks = [].concat(options.tasks); // Store calls to trigger after the transaction has ended.

    this.endedCallbacks = new Set();
    StateCache.set(domNode, this.state);
  }

  start() {
    if (process_default_0.env.NODE_ENV !== 'production') {
      Transaction.assert(this);
    }

    const {
      domNode,
      state: {
        measure
      },
      tasks
    } = this;
    const takeLastTask = tasks.pop();
    this.aborted = false; // Add middleware in as tasks.

    Transaction.invokeMiddleware(this); // Measure the render flow if the user wants to track performance.

    measure('render'); // Push back the last task as part of ending the flow.

    tasks.push(takeLastTask);
    return Transaction.flow(this, tasks);
  } // This will immediately call the last flow task and terminate the flow. We
  // call the last task to ensure that the control flow completes. This should
  // end psuedo-synchronously. Think `Promise.resolve()`, `callback()`, and
  // doesn't matter practically besides that.


  abort(isReturn) {
    const {
      state
    } = this;
    this.aborted = true; // Grab the last task in the flow and return, this task will be responsible
    // for calling `transaction.end`.

    if (isReturn) {
      return this.tasks[this.tasks.length - 1](this);
    }
  }

  end() {
    const {
      state,
      domNode,
      options
    } = this;
    const {
      measure
    } = state;
    const {
      inner
    } = options;
    measure('finalize');
    this.completed = true; // Mark the end to rendering.

    measure('finalize');
    measure('render'); // Trigger all `onceEnded` callbacks, so that middleware can know the
    // transaction has ended.

    this.endedCallbacks.forEach(callback => callback(this));
    this.endedCallbacks.clear(); // Cache the markup and text for the DOM node to allow for short-circuiting
    // future render transactions.

    state.previousMarkup = domNode.outerHTML;
    state.isRendering = false; // Clean up memory before rendering the next transaction, however if
    // another transaction is running concurrently this will be delayed until
    // the last render completes.

    cleanMemory();
    return this;
  }

  onceEnded(callback) {
    this.endedCallbacks.add(callback);
  }

};

const inner_html_default_0 = function innerHTML(domNode, markup = '', options = {}) {
  options.inner = true;
  options.tasks = options.tasks || defaultTasks;
  return transaction_default_0.create(domNode, markup, options).start();
};

const outer_html_default_0 = function outerHTML(domNode, markup = '', options = {}) {
  options.inner = false;
  options.tasks = options.tasks || defaultTasks;
  return transaction_default_0.create(domNode, markup, options).start();
};

const release_default_0 = function release(domNode) {
  // Try and find a state object for this DOM Node.
  const state = StateCache.get(domNode);

  if (state && state.oldTree) {
    unprotectVTree(state.oldTree);
  } // Remove the DOM Node's state object from the cache.


  StateCache.delete(domNode); // Recycle all unprotected objects.

  cleanMemory();
};

const {
  CreateTreeHookCache: use_CreateTreeHookCache_1,
  CreateNodeHookCache: use_CreateNodeHookCache_1,
  SyncTreeHookCache: use_SyncTreeHookCache_1,
  ReleaseHookCache: use_ReleaseHookCache_1
} = MiddlewareCache;

const use_default_0 = function use(middleware) {
  if (process_default_0.env.NODE_ENV !== 'production') {
    if (typeof middleware !== 'function') {
      throw new Error('Middleware must be a function');
    }
  }

  const {
    subscribe,
    unsubscribe,
    createTreeHook,
    createNodeHook,
    syncTreeHook,
    releaseHook
  } = middleware; // Add the function to the set of middlewares.

  MiddlewareCache.add(middleware); // Call the subscribe method if it was defined, passing in the full public
  // API we have access to at this point.

  subscribe && middleware.subscribe(); // Add the hyper-specific create hooks.

  createTreeHook && use_CreateTreeHookCache_1.add(createTreeHook);
  createNodeHook && use_CreateNodeHookCache_1.add(createNodeHook);
  syncTreeHook && use_SyncTreeHookCache_1.add(syncTreeHook);
  releaseHook && use_ReleaseHookCache_1.add(releaseHook); // The unsubscribe method for the middleware.

  return () => {
    // Remove this middleware from the internal cache. This will prevent it
    // from being invoked in the future.
    MiddlewareCache.delete(middleware); // Call the unsubscribe method if defined in the middleware (allows them
    // to cleanup).

    unsubscribe && unsubscribe(); // Cleanup the specific fns from their Cache.

    use_CreateTreeHookCache_1.delete(createTreeHook);
    use_CreateNodeHookCache_1.delete(createNodeHook);
    use_SyncTreeHookCache_1.delete(syncTreeHook);
    use_ReleaseHookCache_1.delete(releaseHook);
  };
};

const internals_memory_1 = {
  protectVTree,
  unprotectVTree,
  cleanMemory
};
const caches = {
  StateCache,
  NodeCache,
  TransitionCache,
  MiddlewareCache
};
const {
  assign
} = Object;
const internals_default_0 = assign({
  decodeEntities: decode_entities_default_0,
  escape: escape_default_0,
  makeMeasure: make_measure_default_0,
  memory: internals_memory_1,
  Pool: pool_default_0,
  process: process_default_0
}, caches);
const VERSION = `${__VERSION__}-runtime`;
const api = {
  VERSION,
  addTransitionState: transition_addTransitionState_1,
  removeTransitionState: transition_removeTransitionState_1,
  release: release_default_0,
  createTree: create_default_0,
  use: use_default_0,
  outerHTML: outer_html_default_0,
  innerHTML: inner_html_default_0,
  html: create_default_0,
  defaultTasks
};
const {
  assign: runtime_assign_1
} = Object; // This is an internal API exported purely for middleware and extensions to
// leverage internal APIs that are not part of the public API. There are no
// promises that this will not break in the future. We will attempt to minimize
// changes and will supply fallbacks when APIs change.

const Internals = runtime_assign_1(internals_default_0, api, {
  defaultTasks,
  tasks,
  createNode: create_default_1,
  syncTree: create_default_0
}); // Attach a circular reference to `Internals` for ES/CJS builds.

api.Internals = Internals; // Automatically hook up to DevTools if they are present.

if (typeof devTools === 'function') {
  use_default_0(devTools(Internals));
  console.warn('diffHTML DevTools: Found and Activated...');
}

this.Internals = Internals;
this.html = create_default_0;
this.innerHTML = inner_html_default_0;
this.outerHTML = outer_html_default_0;
this.use = use_default_0;
this.createTree = create_default_0;
this.release = release_default_0;
this.removeTransitionState = transition_removeTransitionState_1;
this.addTransitionState = transition_addTransitionState_1;
this.VERSION = VERSION;
this.diffhtml = api;