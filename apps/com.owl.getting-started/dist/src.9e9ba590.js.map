{"version":3,"sources":["../src/shim.ts","../src/utils.ts","../src/BaseComponent.ts","../src/Component.ts","../src/Widget.ts","../../../../../.nvm/versions/node/v12.14.1/lib/node_modules/parcel/node_modules/events/events.js","../node_modules/diffhtml/dist/es/util/caches.js","../node_modules/diffhtml/dist/es/util/pool.js","../node_modules/diffhtml/dist/es/tree/create.js","../../../../../.nvm/versions/node/v12.14.1/lib/node_modules/parcel/node_modules/process/browser.js","../node_modules/diffhtml/dist/es/util/process.js","../node_modules/diffhtml/dist/es/node/create.js","../node_modules/diffhtml/dist/es/util/parse.js","../node_modules/diffhtml/dist/es/tasks/parse-new-tree.js","../node_modules/diffhtml/dist/es/util/memory.js","../node_modules/diffhtml/dist/es/tasks/reconcile-trees.js","../node_modules/diffhtml/dist/es/util/decode-entities.js","../node_modules/diffhtml/dist/es/util/escape.js","../node_modules/diffhtml/dist/es/util/make-measure.js","../node_modules/diffhtml/dist/es/util/internals.js","../node_modules/diffhtml/dist/es/tasks/schedule.js","../node_modules/diffhtml/dist/es/tasks/should-update.js","../node_modules/diffhtml/dist/es/tree/sync.js","../node_modules/diffhtml/dist/es/tasks/sync-trees.js","../node_modules/diffhtml/dist/es/transition.js","../node_modules/diffhtml/dist/es/node/patch.js","../node_modules/diffhtml/dist/es/tasks/patch-node.js","../node_modules/diffhtml/dist/es/tasks/end-as-promise.js","../node_modules/diffhtml/dist/es/transaction.js","../node_modules/diffhtml/dist/es/inner-html.js","../node_modules/diffhtml/dist/es/outer-html.js","../node_modules/diffhtml/dist/es/html.js","../node_modules/diffhtml/dist/es/release.js","../node_modules/diffhtml/dist/es/use.js","../node_modules/diffhtml/dist/es/version.js","../node_modules/diffhtml/dist/es/index.js","../../src/plugins/diffing.ts","../../src/plugins/templatePraser.ts","../src/StatefulWidget.ts","../src/StatelessWidget.ts","../src/index.ts","Root.ts","Card.ts","Button.ts","Content.ts","index.ts"],"names":["ReflectOwnKeys","R","Reflect","ReflectApply","apply","target","receiver","args","Function","prototype","call","ProcessEmitWarning","warning","console","warn","ownKeys","Object","getOwnPropertySymbols","getOwnPropertyNames","concat","NumberIsNaN","Number","isNaN","value","EventEmitter","init","module","exports","_events","undefined","_eventsCount","_maxListeners","defaultMaxListeners","checkListener","listener","TypeError","_getMaxListeners","that","_addListener","type","prepend","m","events","existing","create","newListener","emit","unshift","push","length","warned","w","Error","String","name","emitter","count","onceWrapper","fired","arguments","removeListener","wrapFn","_onceWrap","state","wrapped","bind","_listeners","unwrap","evlistener","unwrapListeners","arrayClone","listenerCount","arr","n","copy","Array","i","spliceOne","list","index","pop","ret","defineProperty","enumerable","get","set","arg","RangeError","getPrototypeOf","setMaxListeners","getMaxListeners","doError","error","er","err","message","context","handler","len","listeners","addListener","on","prependListener","once","prependOnceListener","position","originalListener","shift","off","removeAllListeners","keys","key","rawListeners","eventNames","StateCache","Map","NodeCache","TransitionCache","MiddlewareCache","Set","CreateTreeHookCache","CreateNodeHookCache","SyncTreeHookCache","ReleaseHookCache","size","free","allocate","protect","shape","rawNodeName","nodeName","nodeValue","nodeType","childNodes","attributes","memory","allocated","protected","add","freeValues","values","done","next","delete","unprotect","has","isArray","fragmentName","createTree","input","rest","newTree","isFragment","isObject","vTree","elementName","children","entry","Pool","isTextNode","isString","toLowerCase","nodes","join","useAttributes","nodeArray","newNode","isNodeArray","src","forEach","fn","retVal","cachedSetTimeout","cachedClearTimeout","process","defaultSetTimout","defaultClearTimeout","runTimeout","fun","setTimeout","e","runClearTimeout","marker","clearTimeout","currentQueue","queue","draining","queueIndex","cleanUpNextTick","drainQueue","timeout","run","Item","array","noop","nextTick","title","env","argv","version","versions","binding","cwd","chdir","dir","umask","NODE_ENV","namespace","createNode","ownerDocument","document","isSVG","existingNode","domNode","createTextNode","createDocumentFragment","createElementNS","createElement","appendChild","hasNonWhitespaceEx","doctypeEx","attrEx","spaceEx","tokenEx","tagEx","assign","blockText","selfClosing","kElementsClosedByOpening","li","p","div","td","th","kElementsClosedByClosing","ul","ol","a","b","tr","table","interpolateValues","currentParent","string","supplemental","test","parts","split","innerTree","HTMLElement","rawAttrs","options","match","exec","tags","tokenMatch","hasToken","newName","strict","nameAndValue","getValue","parse","html","root","stack","lastTextPos","includes","text","lastIndex","slice","matchOffset","closeMarkup","indexOf","newText","tag","remainingText","trim","head","before","after","body","HTML","beforeHead","beforeBody","filter","el","headInstance","bodyInstance","parseNewTree","transaction","markup","measure","inner","protectVTree","unprotectVTree","cleanMemory","isBusy","isRendering","clear","node","reconcileTrees","previousMarkup","outerHTML","oldTree","isUnknown","g","global","window","element","decodeEntities","innerHTML","textContent","escape","unescaped","replace","charCodeAt","marks","prefix","DIFF_PERF","hasSearch","location","hasArguments","nop","wantsSearch","search","wantsArguments","host","constructor","endName","totalMs","performance","now","toFixed","mark","makeMeasure","caches","schedule","activeTransaction","nextTransaction","tasks","chainTransaction","abort","promise","Promise","resolve","then","aborted","Transaction","flow","shouldUpdate","prop","empty","keyNames","syncTree","patches","parentTree","specialCase","oldNodeName","isEmpty","keysLookup","old","new","keyName","map","shortCircuit","SET_ATTRIBUTE","REMOVE_ATTRIBUTE","TREE_OPS","NODE_VALUE","patchset","INSERT_BEFORE","REMOVE_CHILD","REPLACE_CHILD","isElement","oldAttributes","newAttributes","newChildNodes","oldChildNodes","oldChildNode","newChildNode","newKey","oldKey","oldInNew","newInOld","optimalNewNode","splice","syncTrees","parentNode","stateNames","addTransitionState","stateName","callback","removeTransitionState","runTransitions","setName","promises","childNode","blacklist","whitelist","removeAttribute","blacklistName","unhandledException","patchNode","_name","oldValue","getAttribute","newPromises","isFunction","style","noValue","setAttribute","all","refTree","refNode","insertBefore","attachedPromises","detachedPromises","removeChild","oldDomNode","newDomNode","allPromises","replaceChild","textChangedPromises","patch","namespaceURI","endAsPromise","end","_createClass","defineProperties","props","descriptor","configurable","writable","Constructor","protoProps","staticProps","_classCallCheck","instance","defaultTasks","endedCallbacks","result","takeLastTask","invokeMiddleware","isReturn","completed","start","isTagEx","TOKEN","nextValue","handleTaggedTemplate","strings","isStrict","lastCharacter","isAttribute","lastIndexOf","isTag","Boolean","_isArray","token","release","use","middleware","subscribe","unsubscribe","createTreeHook","createNodeHook","syncTreeHook","releaseHook","__VERSION__","api","VERSION","Internals","internals","devTools"],"mappings":"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","file":"src.9e9ba590.js","sourceRoot":"../src","sourcesContent":["/**\r\n * @license\r\n * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.\r\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\r\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\r\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\r\n * Code distributed by Google as part of the polymer project is also\r\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\r\n */\r\n\r\n/**\r\n * This shim allows elements written in, or compiled to, ES5 to work on native\r\n * implementations of Custom Elements v1. It sets new.target to the value of\r\n * this.constructor so that the native HTMLElement constructor can access the\r\n * current under-construction element's definition.\r\n */\r\nexport function shim () {\r\n    const _window = <any>window;\r\n    if (\r\n      // No Reflect, no classes, no need for shim because native custom elements\r\n      // require ES2015 classes or Reflect.\r\n      _window.Reflect === undefined ||\r\n      _window.customElements === undefined ||\r\n      // The webcomponentsjs custom elements polyfill doesn't require\r\n      // ES2015-compatible construction (`super()` or `Reflect.construct`).\r\n      _window.customElements.polyfillWrapFlushCallback\r\n    ) {\r\n      return;\r\n    }\r\n    const BuiltInHTMLElement = HTMLElement;\r\n    _window.HTMLElement = /** @this {!Object} */ function HTMLElement() {\r\n      return Reflect.construct(\r\n          BuiltInHTMLElement, [], /** @type {!Function} */ (this.constructor));\r\n    };\r\n    HTMLElement.prototype = BuiltInHTMLElement.prototype;\r\n    HTMLElement.prototype.constructor = HTMLElement;\r\n    Object.setPrototypeOf(HTMLElement, BuiltInHTMLElement);\r\n  }","import { Widget } from './Widget';\r\n\r\nconst global_refs = {};\r\n\r\nexport type State = any;\r\nexport type StateTransformers = any;\r\n\r\nexport function registerRef(ref: string, component: Widget){\r\n    global_refs[ref] = component;\r\n}\r\n\r\nexport function getRef(ref: string): Widget{\r\n    return global_refs[ref];\r\n}\r\n\r\nexport function useComponent(comp: new () => any){\r\n    return {\r\n        as: (name: string) => {\r\n            customElements.define(name, comp);\r\n        }\r\n    }\r\n}","export class BaseComponent extends HTMLElement {\r\n    private parentNodes = [];\r\n    private baseMutationObserver\r\n    constructor() {\r\n        super()\r\n    }\r\n  \r\n    setup() {\r\n        // collect the parentNodes\r\n        let el: Node = this;\r\n        while (el.parentNode) {\r\n            el = el.parentNode\r\n            this.parentNodes.push(el)\r\n        }\r\n        // check if the parser has already passed the end tag of the component\r\n        // in which case this element, or one of its parents, should have a nextSibling\r\n        // if not (no whitespace at all between tags and no nextElementSiblings either)\r\n        // resort to DOMContentLoaded or load having triggered\r\n        if ([this, ...this.parentNodes].some(el=> el.nextSibling) || document.readyState !== 'loading') {\r\n            this.childrenAvailableCallback();\r\n        } else {\r\n            this.baseMutationObserver = new MutationObserver(() => {\r\n                if ([this, ...this.parentNodes].some(el=> el.nextSibling) || document.readyState !== 'loading') {\r\n                    this.childrenAvailableCallback()\r\n                    this.baseMutationObserver.disconnect()\r\n                }\r\n            });\r\n    \r\n            this.baseMutationObserver.observe(this, {childList: true});\r\n        }\r\n    }\r\n\r\n    childrenAvailableCallback(){}\r\n}","import { BaseComponent } from \"./BaseComponent\";\r\n\r\nimport { registerRef } from \"./utils\";\r\nimport { Widget } from \"./Widget\";\r\n\r\nexport class Component extends BaseComponent {\r\n    public component: Widget;\r\n    public widgetChildren: string;\r\n\r\n    constructor(){\r\n        super();\r\n    }\r\n\r\n\r\n    childrenAvailableCallback(){\r\n        if(this.getAttribute('$ref')){\r\n            registerRef(this.getAttribute('$ref'), this.component);\r\n        }\r\n\r\n        this.widgetChildren = this.innerHTML;\r\n    }\r\n\r\n    disconnectedCallback(){\r\n        this.component.onDismount();\r\n    }\r\n}","import { Component } from \"./component\";\r\nimport { State, StateTransformers, getRef } from \"./utils\";\r\n\r\nexport class Widget extends Component {\r\n    public state: State;\r\n    public root: HTMLElement;\r\n    public transformers: StateTransformers;\r\n    constructor(state: State, transformers?: StateTransformers){\r\n        super();\r\n        this.component = this;\r\n        this.state = state;\r\n        this.transformers = transformers;\r\n        transformers && this.transformState(transformers, state);\r\n    }\r\n\r\n    protected transformState(transformers: StateTransformers, state: State){\r\n        Object.getOwnPropertyNames(transformers).forEach( v => {\r\n            state[v] = transformers[v](state[v]);\r\n        })\r\n    }\r\n\r\n    $ref<T>(name: string): T {\r\n        return <any>getRef(name);\r\n    }\r\n\r\n    $child<T>(selector: string): T {\r\n        return <any>this.root.querySelector(selector);\r\n    }\r\n\r\n    public onMount(){}\r\n    public onDismount(){}\r\n\r\n    _render(state?: State): string{\r\n        this.transformers && this.transformState(this.transformers, state);\r\n        if(state){\r\n            this.state = state;\r\n        }\r\n        return this.render(state || this.state);\r\n    }\r\n\r\n    public render(state: State): string{\r\n        return '';\r\n    }\r\n}","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n","// Associates DOM Nodes with state objects.\nexport const StateCache = new Map();\n\n// Associates Virtual Tree Elements with DOM Nodes.\nexport const NodeCache = new Map();\n\n// Cache transition functions.\nexport const TransitionCache = new Map();\n\n// Caches all middleware. You cannot unset a middleware once it has been added.\nexport const MiddlewareCache = new Set();\n\n// Very specific caches used by middleware.\nMiddlewareCache.CreateTreeHookCache = new Set();\nMiddlewareCache.CreateNodeHookCache = new Set();\nMiddlewareCache.SyncTreeHookCache = new Set();\nMiddlewareCache.ReleaseHookCache = new Set();","// A modest size.\nconst size = 10000;\n\nconst free = new Set();\nconst allocate = new Set();\nconst protect = new Set();\nconst shape = () => ({\n  rawNodeName: '',\n  nodeName: '',\n  nodeValue: '',\n  nodeType: 1,\n  key: '',\n  childNodes: [],\n  attributes: {}\n});\n\n// Creates a pool to query new or reused values from.\nconst memory = { free, allocated: allocate, protected: protect };\n\n// Prime the free memory pool with VTrees.\nfor (let i = 0; i < size; i++) {\n  free.add(shape());\n}\n\n// Cache the values object, we'll refer to this iterator which is faster\n// than calling it every single time. It gets replaced once exhausted.\nlet freeValues = free.values();\n\n// Cache VTree objects in a pool which is used to get\nexport default {\n  size,\n  memory,\n\n  get() {\n    const { value = shape(), done } = freeValues.next();\n\n    // This extra bit of work allows us to avoid calling `free.values()` every\n    // single time an object is needed.\n    if (done) {\n      freeValues = free.values();\n    }\n\n    free.delete(value);\n    allocate.add(value);\n    return value;\n  },\n\n  protect(value) {\n    allocate.delete(value);\n    protect.add(value);\n  },\n\n  unprotect(value) {\n    if (protect.has(value)) {\n      protect.delete(value);\n      free.add(value);\n    }\n  }\n};","import { NodeCache, MiddlewareCache } from '../util/caches';\nimport Pool from '../util/pool';\n\nconst { CreateTreeHookCache } = MiddlewareCache;\nconst { isArray } = Array;\nconst fragmentName = '#document-fragment';\n\nexport default function createTree(input, attributes, childNodes, ...rest) {\n  // If no input was provided then we return an indication as such.\n  if (!input) {\n    return null;\n  }\n\n  // If the first argument is an array, we assume this is a DOM fragment and\n  // the array are the childNodes.\n  if (isArray(input)) {\n    childNodes = [];\n\n    for (let i = 0; i < input.length; i++) {\n      const newTree = createTree(input[i]);\n      if (!newTree) {\n        continue;\n      }\n      const isFragment = newTree.nodeType === 11;\n\n      if (typeof newTree.rawNodeName === 'string' && isFragment) {\n        childNodes.push(...newTree.childNodes);\n      } else {\n        childNodes.push(newTree);\n      }\n    }\n\n    return createTree(fragmentName, null, childNodes);\n  }\n\n  const isObject = typeof input === 'object';\n\n  // Crawl an HTML or SVG Element/Text Node etc. for attributes and children.\n  if (input && isObject && 'parentNode' in input) {\n    attributes = {};\n    childNodes = [];\n\n    // When working with a text node, simply save the nodeValue as the\n    // initial value.\n    if (input.nodeType === 3) {\n      childNodes = input.nodeValue;\n    }\n    // Element types are the only kind of DOM node we care about attributes\n    // from. Shadow DOM, Document Fragments, Text, Comment nodes, etc. can\n    // ignore this.\n    else if (input.nodeType === 1 && input.attributes.length) {\n        attributes = {};\n\n        for (let i = 0; i < input.attributes.length; i++) {\n          const { name, value } = input.attributes[i];\n\n          // If the attribute's value is empty, seek out the property instead.\n          if (value === '' && name in input) {\n            attributes[name] = input[name];\n            continue;\n          }\n\n          attributes[name] = value;\n        }\n      }\n\n    // Get the child nodes from an Element or Fragment/Shadow Root.\n    if (input.nodeType === 1 || input.nodeType === 11) {\n      if (input.childNodes.length) {\n        childNodes = [];\n\n        for (let i = 0; i < input.childNodes.length; i++) {\n          childNodes.push(createTree(input.childNodes[i]));\n        }\n      }\n    }\n\n    const vTree = createTree(input.nodeName, attributes, childNodes);\n    NodeCache.set(vTree, input);\n    return vTree;\n  }\n\n  // Assume any object value is a valid VTree object.\n  if (isObject) {\n    // Support JSX-like object shape.\n    if ('children' in input && !('childNodes' in input)) {\n      const nodeName = input.nodeName || input.elementName;\n      return createTree(nodeName, input.attributes, input.children);\n    }\n\n    return input;\n  }\n\n  // Support JSX-style children being passed.\n  if (rest.length) {\n    childNodes = [childNodes, ...rest];\n  }\n\n  // Allocate a new VTree from the pool.\n  const entry = Pool.get();\n  const isTextNode = input === '#text';\n  const isString = typeof input === 'string';\n\n  entry.key = '';\n  entry.rawNodeName = input;\n  entry.nodeName = isString ? input.toLowerCase() : '#document-fragment';\n  entry.childNodes.length = 0;\n  entry.nodeValue = '';\n  entry.attributes = {};\n\n  if (isTextNode) {\n    const nodes = arguments.length === 2 ? attributes : childNodes;\n    const nodeValue = isArray(nodes) ? nodes.join('') : nodes;\n\n    entry.nodeType = 3;\n    entry.nodeValue = String(nodeValue || '');\n\n    return entry;\n  }\n\n  if (input === fragmentName || typeof input !== 'string') {\n    entry.nodeType = 11;\n  } else if (input === '#comment') {\n    entry.nodeType = 8;\n  } else {\n    entry.nodeType = 1;\n  }\n\n  const useAttributes = isArray(attributes) || typeof attributes !== 'object';\n  const nodes = useAttributes ? attributes : childNodes;\n  const nodeArray = isArray(nodes) ? nodes : [nodes];\n\n  if (nodes && nodeArray.length) {\n    for (let i = 0; i < nodeArray.length; i++) {\n      const newNode = nodeArray[i];\n      const isNodeArray = isArray(newNode);\n\n      // Merge in arrays.\n      if (isNodeArray) {\n        for (let i = 0; i < newNode.length; i++) {\n          entry.childNodes.push(newNode[i]);\n        }\n      }\n      // Skip over `null` nodes.\n      else if (!newNode) {\n          continue;\n        }\n        // Merge in fragments.\n        else if (newNode.nodeType === 11 && typeof newNode.rawNodeName === 'string') {\n            for (let i = 0; i < newNode.childNodes.length; i++) {\n              entry.childNodes.push(newNode.childNodes[i]);\n            }\n          }\n          // Assume objects are vTrees.\n          else if (newNode && typeof newNode === 'object') {\n              entry.childNodes.push(newNode);\n            }\n            // Cover generate cases where a user has indicated they do not want a\n            // node from appearing.\n            else if (newNode) {\n                entry.childNodes.push(createTree('#text', null, newNode));\n              }\n    }\n  }\n\n  if (attributes && typeof attributes === 'object' && !isArray(attributes)) {\n    entry.attributes = attributes;\n  }\n\n  // If is a script tag and has a src attribute, key off that.\n  if (entry.nodeName === 'script' && entry.attributes.src) {\n    entry.key = String(entry.attributes.src);\n  }\n\n  // Set the `key` prop if passed as an attr, overrides `script[src]`.\n  if (entry.attributes && 'key' in entry.attributes) {\n    entry.key = String(entry.attributes.key);\n  }\n\n  let vTree = entry;\n\n  CreateTreeHookCache.forEach((fn, retVal) => {\n    // Invoke all the `createNodeHook` functions passing along this transaction\n    // as the only argument. These functions must return valid vTree values.\n    if (retVal = fn(vTree)) {\n      vTree = retVal;\n    }\n  });\n\n  return vTree;\n}","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","export default typeof process !== 'undefined' ? process : {\n  env: { NODE_ENV: 'development' }\n};","import { NodeCache, MiddlewareCache } from '../util/caches';\nimport process from '../util/process';\n\nconst { CreateNodeHookCache } = MiddlewareCache;\nconst namespace = 'http://www.w3.org/2000/svg';\n\n/**\n * Takes in a Virtual Tree Element (VTree) and creates a DOM Node from it.\n * Sets the node into the Node cache. If this VTree already has an\n * associated node, it will reuse that.\n *\n * @param {Object} - A Virtual Tree Element or VTree-like element\n * @param {Object} - Document to create Nodes in\n * @param {Boolean} - Is their a root SVG element?\n * @return {Object} - A DOM Node matching the vTree\n */\nexport default function createNode(vTree, ownerDocument = document, isSVG) {\n  if (process.env.NODE_ENV !== 'production') {\n    if (!vTree) {\n      throw new Error('Missing VTree when trying to create DOM Node');\n    }\n  }\n\n  const existingNode = NodeCache.get(vTree);\n\n  // If the DOM Node was already created, reuse the existing node.\n  if (existingNode) {\n    if (existingNode.nodeName.toLowerCase() !== vTree.nodeName) {\n      throw new Error('Shit is wrong');\n    }\n\n    return existingNode;\n  }\n\n  const { nodeName, rawNodeName = nodeName, childNodes = [] } = vTree;\n  isSVG = isSVG || nodeName === 'svg';\n\n  // Will vary based on the properties of the VTree.\n  let domNode = null;\n\n  CreateNodeHookCache.forEach((fn, retVal) => {\n    // Invoke all the `createNodeHook` functions passing along the vTree as the\n    // only argument. These functions must return a valid DOM Node value.\n    if (retVal = fn(vTree)) {\n      domNode = retVal;\n    }\n  });\n\n  if (!domNode) {\n    // Create empty text elements. They will get filled in during the patch\n    // process.\n    if (nodeName === '#text') {\n      domNode = ownerDocument.createTextNode(vTree.nodeValue);\n    }\n    // Support dynamically creating document fragments.\n    else if (nodeName === '#document-fragment') {\n        domNode = ownerDocument.createDocumentFragment();\n      }\n      // Support SVG.\n      else if (isSVG) {\n          domNode = ownerDocument.createElementNS(namespace, rawNodeName);\n        }\n        // If not a Text or SVG Node, then create with the standard method.\n        else {\n            domNode = ownerDocument.createElement(rawNodeName);\n          }\n  }\n\n  // Add to the domNodes cache.\n  NodeCache.set(vTree, domNode);\n\n  // Append all the children into the domNode, making sure to run them\n  // through this `createNode` function as well.\n  for (let i = 0; i < childNodes.length; i++) {\n    domNode.appendChild(createNode(childNodes[i], ownerDocument, isSVG));\n  }\n\n  return domNode;\n}","// Adapted implementation from:\n// https://github.com/ashi009/node-fast-html-parser\n\nimport createTree from '../tree/create';\nimport Pool from './pool';\nimport process from './process';\n\nconst hasNonWhitespaceEx = /\\S/;\nconst doctypeEx = /<!.*>/i;\nconst attrEx = /\\b([_a-z][_a-z0-9\\-]*)\\s*(=\\s*(\"([^\"]+)\"|'([^']+)'|(\\S+)))?/ig;\nconst spaceEx = /[^ ]/;\nconst tokenEx = /__DIFFHTML__([^_]*)__/;\nconst tagEx = /<!--[^]*?(?=-->)-->|<(\\/?)([a-z\\-\\_][a-z0-9\\-\\_]*)\\s*([^>]*?)(\\/?)>/ig;\n\nconst { assign } = Object;\nconst { isArray } = Array;\n\nconst blockText = new Set(['script', 'noscript', 'style', 'code', 'template']);\n\nconst selfClosing = new Set(['meta', 'img', 'link', 'input', 'area', 'br', 'hr', 'area', 'base', 'br', 'col', 'embed', 'hr', 'img', 'input', 'keygen', 'link', 'meta', 'param', 'source', 'track', 'wbr']);\n\nconst kElementsClosedByOpening = {\n  li: { li: true },\n  p: { p: true, div: true },\n  td: { td: true, th: true },\n  th: { td: true, th: true }\n};\n\nconst kElementsClosedByClosing = {\n  li: { ul: true, ol: true },\n  a: { div: true },\n  b: { div: true },\n  i: { div: true },\n  p: { div: true },\n  td: { tr: true, table: true },\n  th: { tr: true, table: true }\n};\n\n/**\n * Interpolate dynamic supplemental values from the tagged template into the\n * tree.\n *\n * @param currentParent\n * @param string\n * @param supplemental\n */\nconst interpolateValues = (currentParent, string, supplemental = {}) => {\n  // If this is text and not a doctype, add as a text node.\n  if (string && !doctypeEx.test(string) && !tokenEx.test(string)) {\n    return currentParent.childNodes.push(createTree('#text', string));\n  }\n\n  const childNodes = [];\n  const parts = string.split(tokenEx);\n  let { length } = parts;\n\n  for (let i = 0; i < parts.length; i++) {\n    const value = parts[i];\n\n    if (!value) {\n      continue;\n    }\n\n    // When we split on the token expression, the capture group will replace\n    // the token's position. So all we do is ensure that we're on an odd\n    // index and then we can source the correct value.\n    if (i % 2 === 1) {\n      const innerTree = supplemental.children[value];\n      if (!innerTree) {\n        continue;\n      }\n      const isFragment = innerTree.nodeType === 11;\n\n      if (typeof innerTree.rawNodeName === 'string' && isFragment) {\n        childNodes.push(...innerTree.childNodes);\n      } else {\n        childNodes.push(innerTree);\n      }\n    } else if (!doctypeEx.test(value)) {\n      childNodes.push(createTree('#text', value));\n    }\n  }\n\n  currentParent.childNodes.push(...childNodes);\n};\n\n/**\n * HTMLElement, which contains a set of children.\n *\n * Note: this is a minimalist implementation, no complete tree structure\n * provided (no parentNode, nextSibling, previousSibling etc).\n *\n * @param {String} nodeName - DOM Node name\n * @param {Object} rawAttrs - DOM Node Attributes\n * @param {Object} supplemental - Interpolated data from a tagged template\n * @return {Object} vTree\n */\nconst HTMLElement = (nodeName, rawAttrs, supplemental, options) => {\n  let match = null;\n\n  // Support dynamic tag names like: `<${MyComponent} />`.\n  if (match = tokenEx.exec(nodeName)) {\n    return HTMLElement(supplemental.tags[match[1]], rawAttrs, supplemental, options);\n  }\n\n  const attributes = {};\n\n  // Migrate raw attributes into the attributes object used by the VTree.\n  for (let match; match = attrEx.exec(rawAttrs || '');) {\n    const name = match[1];\n    const value = match[6] || match[5] || match[4] || match[1];\n    let tokenMatch = value.match(tokenEx);\n\n    // If we have multiple interpolated values in an attribute, we must\n    // flatten to a string. There are no other valid options.\n    if (tokenMatch && tokenMatch.length) {\n      const parts = value.split(tokenEx);\n      let { length } = parts;\n\n      const hasToken = tokenEx.exec(name);\n      const newName = hasToken ? supplemental.attributes[hasToken[1]] : name;\n\n      for (let i = 0; i < parts.length; i++) {\n        const value = parts[i];\n\n        if (!value) {\n          continue;\n        }\n\n        // When we split on the token expression, the capture group will\n        // replace the token's position. So all we do is ensure that we're on\n        // an odd index and then we can source the correct value.\n        if (i % 2 === 1) {\n          if (attributes[newName]) {\n            attributes[newName] += supplemental.attributes[value];\n          } else {\n            const isObject = typeof newName === 'object';\n\n            if (isObject && !isArray(newName) && newName) {\n              assign(attributes, newName);\n            } else if (isObject && options.strict) {\n              if (process.env.NODE_ENV !== 'production') {\n                attrEx.lastIndex = 0;\n                tagEx.lastIndex = 0;\n\n                throw new Error('Arrays are not allowed to be spread in strict mode');\n              }\n            } else if (newName && typeof newName !== 'object') {\n              attributes[newName] = supplemental.attributes[value];\n            }\n          }\n        }\n        // Otherwise this is a static iteration, simply concat in the raw value.\n        else {\n            if (attributes[newName]) {\n              attributes[newName] += value;\n            } else {\n              attributes[newName] = value;\n            }\n          }\n      }\n    } else if (tokenMatch = tokenEx.exec(name)) {\n      const nameAndValue = supplemental.attributes[tokenMatch[1]];\n      const hasToken = tokenEx.exec(value);\n      const getValue = hasToken ? supplemental.attributes[hasToken[1]] : value;\n\n      attributes[nameAndValue] = value === '\"\"' ? '' : getValue;\n    } else {\n      attributes[name] = value === '\"\"' ? '' : value;\n    }\n  }\n\n  return createTree(nodeName, attributes, []);\n};\n\n/**\n * Parses HTML and returns a root element\n *\n * @param {String} html - String of HTML markup to parse into a Virtual Tree\n * @param {Object} supplemental - Dynamic interpolated data values\n * @param {Object} options - Contains options like silencing warnings\n * @return {Object} - Parsed Virtual Tree Element\n */\nexport default function parse(html, supplemental, options = {}) {\n  const root = createTree('#document-fragment', null, []);\n  const stack = [root];\n  let currentParent = root;\n  let lastTextPos = -1;\n\n  if (process.env.NODE_ENV !== 'production') {\n    const markup = [html];\n\n    if (!html.includes('<') && options.strict) {\n      markup.splice(1, 0, `\nPossibly invalid markup. Opening tag was not properly opened.\n      `);\n\n      throw new Error(`\\n\\n${markup.join('\\n')}`);\n    }\n\n    if (!html.includes('>') && options.strict) {\n      markup.splice(1, 0, `\nPossibly invalid markup. Opening tag was not properly closed.\n      `);\n\n      throw new Error(`\\n\\n${markup.join('\\n')}`);\n    }\n  }\n\n  // If there are no HTML elements, treat the passed in html as a single\n  // text node.\n  if (!html.includes('<') && html) {\n    interpolateValues(currentParent, html, supplemental);\n    return root;\n  }\n\n  // Look through the HTML markup for valid tags.\n  for (let match, text, i = 0; match = tagEx.exec(html); i++) {\n    if (lastTextPos > -1) {\n      if (lastTextPos + match[0].length < tagEx.lastIndex) {\n        text = html.slice(lastTextPos, tagEx.lastIndex - match[0].length);\n\n        if (text) {\n          interpolateValues(currentParent, text, supplemental);\n        }\n      }\n    }\n\n    const matchOffset = tagEx.lastIndex - match[0].length;\n\n    if (lastTextPos === -1 && matchOffset > 0) {\n      const string = html.slice(0, matchOffset);\n\n      if (string && hasNonWhitespaceEx.test(string) && !doctypeEx.exec(string)) {\n        interpolateValues(currentParent, string, supplemental);\n      }\n    }\n\n    lastTextPos = tagEx.lastIndex;\n\n    // This is a comment (TODO support these).\n    if (match[0][1] === '!') {\n      continue;\n    }\n\n    if (!match[1]) {\n      // not </ tags\n      const attrs = {};\n\n      if (!match[4] && kElementsClosedByOpening[currentParent.rawNodeName]) {\n        if (kElementsClosedByOpening[currentParent.rawNodeName][match[2]]) {\n          stack.pop();\n          currentParent = stack[stack.length - 1];\n        }\n      }\n\n      currentParent = currentParent.childNodes[currentParent.childNodes.push(HTMLElement(match[2], match[3], supplemental, options)) - 1];\n\n      stack.push(currentParent);\n\n      if (options.strict || blockText.has(match[2])) {\n        // A little test to find next </script> or </style> ...\n        const closeMarkup = '</' + match[2] + '>';\n        const index = html.indexOf(closeMarkup, tagEx.lastIndex);\n        const { length } = match[2];\n\n        if (process.env.NODE_ENV !== 'production') {\n          if (index === -1 && options.strict) {\n            const nodeName = currentParent.rawNodeName;\n\n            // Find a subset of the markup passed in to validate.\n            const markup = html.slice(tagEx.lastIndex - match[0].length).split('\\n').slice(0, 3);\n\n            // Position the caret next to the first non-whitespace character.\n            const caret = Array(spaceEx.exec(markup[0]).index + closeMarkup.length - 1).join(' ') + '^';\n\n            const name = supplemental ? supplemental.tags[0].name : match[2];\n\n            // Craft the warning message and inject it into the markup.\n            markup.splice(1, 0, `${caret}\n    Possibly invalid markup. <${name}> is not a self closing tag.\n            `);\n\n            // As we are about to throw an error, make sure to reset the global\n            // `lastIndex` property.\n            attrEx.lastIndex = 0;\n            tagEx.lastIndex = 0;\n\n            // Throw an error message if the markup isn't what we expected.\n            throw new Error(`\\n\\n${markup.join('\\n')}`);\n          }\n        }\n\n        if (index === -1) {\n          lastTextPos = tagEx.lastIndex = html.length + 1;\n        } else {\n          lastTextPos = index + closeMarkup.length;\n          tagEx.lastIndex = lastTextPos;\n          match[1] = true;\n        }\n\n        const newText = html.slice(match.index + match[0].length, index);\n        interpolateValues(currentParent, newText, supplemental);\n      }\n    }\n\n    if (match[1] || match[4] || selfClosing.has(match[2])) {\n      if (process.env.NODE_ENV !== 'production') {\n        if (currentParent && match[2] !== currentParent.rawNodeName && options.strict) {\n          const nodeName = currentParent.rawNodeName;\n\n          // Find a subset of the markup passed in to validate.\n          const markup = html.slice(tagEx.lastIndex - match[0].length).split('\\n').slice(0, 3);\n\n          // Position the caret next to the first non-whitespace character.\n          const caret = Array(spaceEx.exec(markup[0]).index).join(' ') + '^';\n\n          // Craft the warning message and inject it into the markup.\n          markup.splice(1, 0, `${caret}\n  Possibly invalid markup. Saw ${match[2]}, expected ${nodeName}...\n          `);\n\n          // As we are about to throw an error, make sure to reset the global\n          // `lastIndex` property.\n          attrEx.lastIndex = 0;\n          tagEx.lastIndex = 0;\n\n          // Throw an error message if the markup isn't what we expected.\n          throw new Error(`\\n\\n${markup.join('\\n')}`);\n        }\n      }\n\n      const tokenMatch = tokenEx.exec(match[2]);\n\n      // </ or /> or <br> etc.\n      while (currentParent) {\n        // Self closing dynamic nodeName.\n        if (match[4] === '/' && tokenMatch) {\n          stack.pop();\n          currentParent = stack[stack.length - 1];\n\n          break;\n        }\n        // Not self-closing, so seek out the next match.\n        else if (tokenMatch) {\n            const value = supplemental.tags[tokenMatch[1]];\n\n            if (currentParent.rawNodeName === value) {\n              stack.pop();\n              currentParent = stack[stack.length - 1];\n\n              break;\n            }\n          }\n\n        if (currentParent.rawNodeName === match[2]) {\n          stack.pop();\n          currentParent = stack[stack.length - 1];\n\n          break;\n        } else {\n          const tag = kElementsClosedByClosing[currentParent.rawNodeName];\n\n          // Trying to close current tag, and move on\n          if (tag) {\n            if (tag[match[2]]) {\n              stack.pop();\n              currentParent = stack[stack.length - 1];\n\n              continue;\n            }\n          }\n\n          // Use aggressive strategy to handle unmatching markups.\n          break;\n        }\n      }\n    }\n  }\n\n  // Find any last remaining text after the parsing completes over tags.\n  const remainingText = html.slice(lastTextPos === -1 ? 0 : lastTextPos).trim();\n\n  if (process.env.NODE_ENV !== 'production') {\n    if ((remainingText.includes('>') || remainingText.includes('<')) && options.strict) {\n      const nodeName = currentParent.rawNodeName;\n\n      // Find a subset of the markup passed in to validate.\n      const markup = [remainingText];\n\n      // Position the caret next to the first non-whitespace character.\n      const caret = Array(spaceEx.exec(markup[0]).index).join(' ') + '^';\n\n      // Craft the warning message and inject it into the markup.\n      if (remainingText.includes('>')) {\n        markup.splice(1, 0, `${caret}\n  Possibly invalid markup. Opening tag was not properly opened.\n        `);\n      } else {\n        markup.splice(1, 0, `${caret}\n  Possibly invalid markup. Opening tag was not properly closed.\n        `);\n      }\n\n      // As we are about to throw an error, make sure to reset the global\n      // `lastIndex` property.\n      attrEx.lastIndex = 0;\n      tagEx.lastIndex = 0;\n\n      // Throw an error message if the markup isn't what we expected.\n      throw new Error(`\\n\\n${markup.join('\\n')}`);\n    }\n  }\n\n  // Ensure that all values are properly interpolated through the remaining\n  // markup after parsing.\n  if (remainingText) {\n    interpolateValues(currentParent, remainingText, supplemental);\n  }\n\n  // This is an entire document, so only allow the HTML children to be\n  // body or head.\n  if (root.childNodes.length && root.childNodes[0].nodeName === 'html') {\n    // Store elements from before body end and after body end.\n    const head = { before: [], after: [] };\n    const body = { after: [] };\n    const HTML = root.childNodes[0];\n\n    let beforeHead = true;\n    let beforeBody = true;\n\n    // Iterate the children and store elements in the proper array for\n    // later concat, replace the current childNodes with this new array.\n    HTML.childNodes = HTML.childNodes.filter(el => {\n      // If either body or head, allow as a valid element.\n      if (el.nodeName === 'body' || el.nodeName === 'head') {\n        if (el.nodeName === 'head') beforeHead = false;\n        if (el.nodeName === 'body') beforeBody = false;\n\n        return true;\n      }\n      // Not a valid nested HTML tag element, move to respective container.\n      else if (el.nodeType === 1) {\n          if (beforeHead && beforeBody) head.before.push(el);else if (!beforeHead && beforeBody) head.after.push(el);else if (!beforeBody) body.after.push(el);\n        }\n    });\n\n    // Ensure the first element is the HEAD tag.\n    if (!HTML.childNodes[0] || HTML.childNodes[0].nodeName !== 'head') {\n      const headInstance = createTree('head', null, []);\n      const existing = headInstance.childNodes;\n\n      existing.unshift.apply(existing, head.before);\n      existing.push.apply(existing, head.after);\n      HTML.childNodes.unshift(headInstance);\n    } else {\n      const existing = HTML.childNodes[0].childNodes;\n\n      existing.unshift.apply(existing, head.before);\n      existing.push.apply(existing, head.after);\n    }\n\n    // Ensure the second element is the body tag.\n    if (!HTML.childNodes[1] || HTML.childNodes[1].nodeName !== 'body') {\n      const bodyInstance = createTree('body', null, []);\n      const existing = bodyInstance.childNodes;\n\n      existing.push.apply(existing, body.after);\n      HTML.childNodes.push(bodyInstance);\n    } else {\n      const existing = HTML.childNodes[1].childNodes;\n      existing.push.apply(existing, body.after);\n    }\n  }\n\n  // Reset regular expression positions per parse.\n  attrEx.lastIndex = 0;\n  tagEx.lastIndex = 0;\n\n  return root;\n}","import { NodeCache } from '../util/caches';\nimport parse from '../util/parse';\nimport createTree from '../tree/create';\n\nexport default function parseNewTree(transaction) {\n  const { state, markup, options } = transaction;\n  const { measure } = state;\n  const { inner } = options;\n\n  if (typeof markup === 'string') {\n    measure('parsing markup for new tree');\n\n    const { childNodes } = parse(markup, null, options);\n\n    // If we are dealing with innerHTML, use all the Nodes. If we're dealing\n    // with outerHTML, we can only support diffing against a single element,\n    // so pick the first one, if there are none, just pass the entire root.\n    transaction.newTree = createTree(inner ? childNodes : childNodes[0] || childNodes);\n\n    measure('parsing markup for new tree');\n  }\n}","import Pool from './pool';\nimport { NodeCache, StateCache, MiddlewareCache } from './caches';\n\nconst { ReleaseHookCache } = MiddlewareCache;\nconst { memory, protect, unprotect } = Pool;\n\n/**\n * Ensures that an vTree is not recycled during a render cycle.\n *\n * @param vTree\n * @return vTree\n */\nexport function protectVTree(vTree) {\n  protect(vTree);\n\n  for (let i = 0; i < vTree.childNodes.length; i++) {\n    protectVTree(vTree.childNodes[i]);\n  }\n\n  return vTree;\n}\n\n/**\n * Allows an vTree to be recycled during a render cycle.\n *\n * @param vTree\n * @return\n */\nexport function unprotectVTree(vTree) {\n  unprotect(vTree);\n\n  if (ReleaseHookCache.size) {\n    ReleaseHookCache.forEach(fn => fn(vTree));\n  }\n\n  for (let i = 0; i < vTree.childNodes.length; i++) {\n    unprotectVTree(vTree.childNodes[i]);\n  }\n\n  return vTree;\n}\n\n/**\n * Moves all unprotected allocations back into available pool. This keeps\n * diffHTML in a consistent state after synchronizing.\n */\nexport function cleanMemory(isBusy = false) {\n  StateCache.forEach(state => isBusy = isBusy || state.isRendering);\n\n  // Clean out unused elements, if we have any elements cached that no longer\n  // have a backing VTree, we can safely remove them from the cache.\n  if (!isBusy) {\n    memory.allocated.forEach(vTree => memory.free.add(vTree));\n    memory.allocated.clear();\n\n    NodeCache.forEach((node, vTree) => {\n      if (!memory.protected.has(vTree)) {\n        NodeCache.delete(vTree);\n\n        if (ReleaseHookCache.size) {\n          ReleaseHookCache.forEach(fn => fn(vTree));\n        }\n      }\n    });\n  }\n}","import { NodeCache } from '../util/caches';\nimport { protectVTree, unprotectVTree } from '../util/memory';\nimport createTree from '../tree/create';\n\nexport default function reconcileTrees(transaction) {\n  const { state, domNode, markup, options } = transaction;\n  const { previousMarkup } = state;\n  const { inner } = options;\n  const { outerHTML } = domNode;\n\n  // We rebuild the tree whenever the DOM Node changes, including the first\n  // time we patch a DOM Node.\n  if (previousMarkup !== outerHTML || !state.oldTree || !outerHTML) {\n    if (state.oldTree) {\n      unprotectVTree(state.oldTree);\n    }\n\n    state.oldTree = createTree(domNode);\n    NodeCache.set(state.oldTree, domNode);\n    protectVTree(state.oldTree);\n  }\n\n  // Associate the old tree with this brand new transaction.\n  transaction.oldTree = state.oldTree;\n\n  // If we are in a render transaction where no markup was previously parsed\n  // then reconcile trees will attempt to create a tree based on the incoming\n  // markup (JSX/html/etc).\n  if (!transaction.newTree) {\n    transaction.newTree = createTree(markup);\n  }\n\n  // If we are diffing only the parent's childNodes, then adjust the newTree to\n  // be a replica of the oldTree except with the childNodes changed.\n  if (inner) {\n    const { oldTree, newTree } = transaction;\n    const { rawNodeName, nodeName, attributes } = oldTree;\n    const isUnknown = typeof newTree.rawNodeName !== 'string';\n    const isFragment = newTree.nodeType === 11;\n    const children = isFragment && !isUnknown ? newTree.childNodes : newTree;\n\n    transaction.newTree = createTree(nodeName, attributes, children);\n  }\n}","// Support loading diffHTML in non-browser environments.\nconst g = typeof global === 'object' ? global : window;\nconst element = g.document ? document.createElement('div') : null;\n\n/**\n * Decodes HTML strings.\n *\n * @see http://stackoverflow.com/a/5796718\n * @param string\n * @return unescaped HTML\n */\nexport default function decodeEntities(string) {\n  // If there are no HTML entities, we can safely pass the string through.\n  if (!element || !string || !string.indexOf || !string.includes('&')) {\n    return string;\n  }\n\n  element.innerHTML = string;\n  return element.textContent;\n}","/**\n * Tiny HTML escaping function, useful to protect against things like XSS and\n * unintentionally breaking attributes with quotes.\n *\n * @param {String} unescaped - An HTML value, unescaped\n * @return {String} - An HTML-safe string\n */\nexport default function escape(unescaped) {\n  return unescaped.replace(/[&<>]/g, match => `&#${match.charCodeAt(0)};`);\n}","export const marks = new Map();\nexport const prefix = 'diffHTML';\nconst DIFF_PERF = 'diff_perf';\n\nconst hasSearch = typeof location !== 'undefined';\nconst hasArguments = typeof process !== 'undefined' && process.argv;\nconst nop = () => {};\n\nexport default ((domNode, vTree) => {\n  // Check for these changes on every check.\n  const wantsSearch = hasSearch && location.search.includes(DIFF_PERF);\n  const wantsArguments = hasArguments && process.argv.includes(DIFF_PERF);\n  const wantsPerfChecks = wantsSearch || wantsArguments;\n\n  // If the user has not requested they want perf checks, return a nop\n  // function.\n  if (!wantsPerfChecks) {\n    return nop;\n  }\n\n  return name => {\n    // Use the Web Component name if it's available.\n    if (domNode && domNode.host) {\n      name = `${domNode.host.constructor.name} ${name}`;\n    } else if (typeof vTree.rawNodeName === 'function') {\n      name = `${vTree.rawNodeName.name} ${name}`;\n    }\n\n    const endName = `${name}-end`;\n\n    if (!marks.has(name)) {\n      marks.set(name, performance.now());\n      performance.mark(name);\n    } else {\n      const totalMs = (performance.now() - marks.get(name)).toFixed(3);\n\n      marks.delete(name);\n\n      performance.mark(endName);\n      performance.measure(`${prefix} ${name} (${totalMs}ms)`, name, endName);\n    }\n  };\n});","import * as caches from './caches';\nimport decodeEntities from './decode-entities';\nimport escape from './escape';\nimport makeMeasure from './make-measure';\nimport * as memory from './memory';\nimport Pool from './pool';\nimport process from './process';\n\nconst { assign } = Object;\n\nexport default assign({\n  decodeEntities,\n  escape,\n  makeMeasure,\n  memory,\n  Pool,\n  process\n}, caches);","import Transaction from '../transaction';\nimport { StateCache } from '../util/caches';\n\n/**\n * If diffHTML is rendering anywhere asynchronously, we need to wait until it\n * completes before this render can be executed. This sets up the next\n * buffer, if necessary, which serves as a Boolean determination later to\n * `bufferSet`.\n *\n * @param {Object} nextTransaction - The Transaction instance to schedule\n * @return {Boolean} - Value used to terminate a transaction render flow\n */\nexport default function schedule(transaction) {\n  // The state is a global store which is shared by all like-transactions.\n  let { state } = transaction;\n\n  const { isRendering, activeTransaction, nextTransaction } = state;\n\n  // If there is an in-flight transaction render happening, push this\n  // transaction into a queue.\n  if (isRendering) {\n    const { tasks } = transaction;\n    const chainTransaction = nextTransaction || activeTransaction;\n\n    // Pave over the `nextTransaction` to chain off the previous.\n    state.nextTransaction = transaction;\n\n    // Abort the remaining tasks (but do not signal completion).\n    transaction.abort();\n\n    const promise = chainTransaction.promise || Promise.resolve();\n\n    return transaction.promise = promise.then(() => {\n      transaction.aborted = false;\n      return Transaction.flow(transaction, tasks.slice(1));\n    });\n  }\n\n  // Indicate we are now rendering a transaction for this DOM Node.\n  state.isRendering = true;\n  state.activeTransaction = transaction;\n}","export default function shouldUpdate(transaction) {\n  const { domNode, markup, state, state: { measure }, options } = transaction;\n  const prop = options.inner ? 'innerHTML' : 'outerHTML';\n\n  measure('should update');\n\n  // If the contents haven't changed, abort the flow. Only support this if\n  // the new markup is a string, otherwise it's possible for our object\n  // recycling to match twice.\n  if (typeof markup === 'string' && domNode[prop] === markup) {\n    return transaction.abort(true);\n  } else if (typeof markup === 'string') {\n    state.markup = markup;\n  }\n\n  measure('should update');\n}","import { MiddlewareCache } from '../util/caches';\nimport process from '../util/process';\n\nconst { SyncTreeHookCache } = MiddlewareCache;\nconst empty = {};\nconst keyNames = ['old', 'new'];\n\n// Compares how the new state should look to the old state and mutates it,\n// while recording the changes along the way.\nexport default function syncTree(oldTree, newTree, patches, parentTree, specialCase) {\n  if (!oldTree) oldTree = empty;\n  if (!newTree) newTree = empty;\n\n  const oldNodeName = oldTree.nodeName;\n  const isFragment = newTree.nodeType === 11;\n  const isEmpty = oldTree === empty;\n  const keysLookup = { old: new Map(), new: new Map() };\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (newTree === empty) {\n      throw new Error('Missing new Virtual Tree to sync changes from');\n    }\n\n    // FIXME: Causes issues w/ React, we need to normalize at a higher level.\n    if (!isEmpty && oldNodeName !== newTree.nodeName && !isFragment) {\n      throw new Error(`Sync failure, cannot compare ${newTree.nodeName} with ${oldNodeName}`);\n    }\n  }\n\n  // Reduce duplicate logic by condensing old and new operations in a loop.\n  for (let i = 0; i < keyNames.length; i++) {\n    const keyName = keyNames[i];\n    const map = keysLookup[keyName];\n    const vTree = arguments[i];\n    const nodes = vTree && vTree.childNodes;\n\n    if (nodes && nodes.length) {\n      for (let i = 0; i < nodes.length; i++) {\n        const vTree = nodes[i];\n\n        if (vTree.key) {\n          if (process.env.NODE_ENV !== 'production') {\n            if (map.has(vTree.key)) {\n              throw new Error(`Key: ${vTree.key} cannot be duplicated`);\n            }\n          }\n\n          map.set(vTree.key, vTree);\n        }\n      }\n    }\n  }\n\n  let shortCircuit = false;\n\n  // Create new arrays for patches or use existing from a recursive call.\n  patches = patches || {\n    SET_ATTRIBUTE: [],\n    REMOVE_ATTRIBUTE: [],\n    TREE_OPS: [],\n    NODE_VALUE: []\n  };\n\n  const { SET_ATTRIBUTE, REMOVE_ATTRIBUTE, TREE_OPS, NODE_VALUE } = patches;\n  const newNodeName = newTree.nodeName;\n\n  // Build up a patchset object to use for tree operations.\n  const patchset = {\n    INSERT_BEFORE: [],\n    REMOVE_CHILD: [],\n    REPLACE_CHILD: []\n  };\n\n  // Invoke any middleware hooks, allow the middleware to replace the\n  // `newTree`. Pass along the `keysLookup` object so that middleware can make\n  // smart decisions when dealing with keys.\n  SyncTreeHookCache.forEach(fn => {\n    oldTree = specialCase || oldTree;\n\n    // Call the user provided middleware function for a single root node. Allow\n    // the consumer to specify a return value of a different VTree (useful for\n    // components).\n    let retVal = fn(oldTree, newTree, keysLookup, parentTree);\n\n    // If the consumer returned a value and it doesn't equal the existing tree,\n    // then splice it into the parent (if it exists) and run a sync.\n    if (retVal && retVal !== newTree) {\n      // Synchronize this new tree.\n      newTree = retVal;\n    } else if (retVal && retVal === oldTree) {\n      shortCircuit = true;\n    }\n  });\n\n  if (shortCircuit) {\n    return patches;\n  }\n\n  // USED: INSERT_BEFORE: 3x, REMOVE_CHILD: 1x, REPLACE_CHILD: 3x.\n  const { INSERT_BEFORE, REMOVE_CHILD, REPLACE_CHILD } = patchset;\n  const isElement = newTree.nodeType === 1;\n\n  // Text nodes are low level and frequently change, so this path is accounted\n  // for first.\n  if (newTree.nodeName === '#text') {\n    // If there was no previous element to compare to, simply set the value\n    // on the new node.\n    if (oldTree.nodeName !== '#text') {\n      NODE_VALUE.push(newTree, newTree.nodeValue, null);\n    }\n    // If both VTrees are text nodes and the values are different, change the\n    // `Element#nodeValue`.\n    else if (!isEmpty && oldTree.nodeValue !== newTree.nodeValue) {\n        NODE_VALUE.push(oldTree, newTree.nodeValue, oldTree.nodeValue);\n        oldTree.nodeValue = newTree.nodeValue;\n      }\n\n    return patches;\n  }\n\n  // Seek out attribute changes first, but only from element Nodes.\n  if (isElement) {\n    const oldAttributes = isEmpty ? empty : oldTree.attributes;\n    const newAttributes = newTree.attributes;\n\n    // Search for sets and changes.\n    for (let key in newAttributes) {\n      const value = newAttributes[key];\n\n      if (key in oldAttributes && oldAttributes[key] === newAttributes[key]) {\n        continue;\n      }\n\n      if (!isEmpty) {\n        oldAttributes[key] = value;\n      }\n\n      SET_ATTRIBUTE.push(isEmpty ? newTree : oldTree, key, value);\n    }\n\n    // Search for removals.\n    if (!isEmpty) {\n      for (let key in oldAttributes) {\n        if (key in newAttributes) {\n          continue;\n        }\n        REMOVE_ATTRIBUTE.push(oldTree, key);\n        delete oldAttributes[key];\n      }\n    }\n  }\n\n  // If we somehow end up comparing two totally different kinds of elements,\n  // we'll want to raise an error to let the user know something is wrong.\n  // FIXME\n  if (process.env.NODE_ENV !== 'production') {\n    if (!isEmpty && oldNodeName !== newNodeName && !isFragment) {\n      throw new Error(`Sync failure, cannot compare ${newNodeName} with ${oldNodeName}`);\n    }\n  }\n\n  const newChildNodes = newTree.childNodes;\n\n  // Scan all childNodes for attribute changes.\n  if (isEmpty) {\n    // Do a single pass over the new child nodes.\n    for (let i = 0; i < newChildNodes.length; i++) {\n      syncTree(null, newChildNodes[i], patches, newTree);\n    }\n\n    return patches;\n  }\n\n  const oldChildNodes = oldTree.childNodes;\n\n  // If we are working with keys, we can follow an optimized path.\n  if (keysLookup.old.size || keysLookup.new.size) {\n    const values = keysLookup.old.values();\n\n    // Do a single pass over the new child nodes.\n    for (let i = 0; i < newChildNodes.length; i++) {\n      const oldChildNode = oldChildNodes[i];\n      const newChildNode = newChildNodes[i];\n      const newKey = newChildNode.key;\n\n      // If there is no old element to compare to, this is a simple addition.\n      if (!oldChildNode) {\n        INSERT_BEFORE.push(oldTree, newChildNode, null);\n        oldChildNodes.push(newChildNode);\n\n        syncTree(null, newChildNode, patches, newTree);\n\n        continue;\n      }\n\n      const oldKey = oldChildNode.key;\n      const oldInNew = keysLookup.new.has(oldKey);\n      const newInOld = keysLookup.old.has(newKey);\n\n      // Remove the old Node and insert the new node (aka replace).\n      if (!oldInNew && !newInOld) {\n        REPLACE_CHILD.push(newChildNode, oldChildNode);\n        oldChildNodes.splice(oldChildNodes.indexOf(oldChildNode), 1, newChildNode);\n\n        syncTree(null, newChildNode, patches, newTree);\n\n        continue;\n      }\n      // Remove the old node instead of replacing.\n      else if (!oldInNew) {\n          REMOVE_CHILD.push(oldChildNode);\n          oldChildNodes.splice(oldChildNodes.indexOf(oldChildNode), 1);\n          i = i - 1;\n          continue;\n        }\n\n      // If there is a key set for this new element, use that to figure out\n      // which element to use.\n      if (newKey !== oldKey) {\n        let optimalNewNode = newChildNode;\n\n        // Prefer existing to new and remove from old position.\n        if (newKey && newInOld) {\n          optimalNewNode = keysLookup.old.get(newKey);\n          oldChildNodes.splice(oldChildNodes.indexOf(optimalNewNode), 1);\n        } else if (newKey) {\n          optimalNewNode = newChildNode;\n\n          // Find attribute changes for this Node.\n          syncTree(null, newChildNode, patches, newTree);\n        }\n\n        INSERT_BEFORE.push(oldTree, optimalNewNode, oldChildNode);\n        oldChildNodes.splice(i, 0, optimalNewNode);\n        continue;\n      }\n\n      // If the element we're replacing is totally different from the previous\n      // replace the entire element, don't bother investigating children.\n      if (oldChildNode.nodeName !== newChildNode.nodeName) {\n        REPLACE_CHILD.push(newChildNode, oldChildNode);\n        oldTree.childNodes[i] = newChildNode;\n\n        syncTree(null, newChildNode, patches, newTree);\n\n        continue;\n      }\n\n      syncTree(oldChildNode, newChildNode, patches, newTree);\n    }\n  }\n\n  // No keys used on this level, so we will do easier transformations.\n  else {\n      // Do a single pass over the new child nodes.\n      for (let i = 0; i < newChildNodes.length; i++) {\n        const oldChildNode = oldChildNodes && oldChildNodes[i];\n        const newChildNode = newChildNodes[i];\n\n        // If there is no old element to compare to, this is a simple addition.\n        if (!oldChildNode) {\n          INSERT_BEFORE.push(oldTree, newChildNode, null);\n\n          if (oldChildNodes) {\n            oldChildNodes.push(newChildNode);\n          }\n\n          syncTree(oldChildNode, newChildNode, patches, oldTree);\n\n          continue;\n        }\n\n        // If the element we're replacing is totally different from the previous\n        // replace the entire element, don't bother investigating children.\n        if (oldChildNode.nodeName !== newChildNode.nodeName) {\n          REPLACE_CHILD.push(newChildNode, oldChildNode);\n          // FIXME Calling this out specifically as a special case since we\n          // have conflicting requirements between synchronization and how\n          // components handle reconcilation. We basically don't want to dig\n          // deeper into the component at the diffHTML level, but want to let\n          // the middleware have access to the old child.\n          //\n          // This avoids sync semantics of oldTree/newTree while still providing\n          // the oldTree to middleware.\n          oldTree.childNodes[i] = newChildNode;\n\n          syncTree(null, newChildNode, patches, oldTree, oldTree.childNodes[i]);\n\n          continue;\n        }\n\n        syncTree(oldChildNode, newChildNode, patches, oldTree);\n      }\n    }\n\n  // We've reconciled new changes, so we can remove any old nodes and adjust\n  // lengths to be equal.\n  if (oldChildNodes.length !== newChildNodes.length) {\n    for (let i = newChildNodes.length; i < oldChildNodes.length; i++) {\n      REMOVE_CHILD.push(oldChildNodes[i]);\n    }\n\n    oldChildNodes.length = newChildNodes.length;\n  }\n\n  // We want to look if anything has changed, if nothing has we won't add it to\n  // the patchset.\n  if (INSERT_BEFORE.length || REMOVE_CHILD.length || REPLACE_CHILD.length) {\n    // Null out the empty arrays.\n    if (!INSERT_BEFORE.length) {\n      patchset.INSERT_BEFORE = null;\n    }\n    if (!REMOVE_CHILD.length) {\n      patchset.REMOVE_CHILD = null;\n    }\n    if (!REPLACE_CHILD.length) {\n      patchset.REPLACE_CHILD = null;\n    }\n\n    TREE_OPS.push(patchset);\n  }\n\n  return patches;\n}","import syncTree from '../tree/sync';\nimport createNode from '../node/create';\nimport { StateCache } from '../util/caches';\nimport { protectVTree, unprotectVTree } from '../util/memory';\n\nexport default function syncTrees(transaction) {\n  const { state: { measure }, oldTree, newTree, domNode } = transaction;\n\n  measure('sync trees');\n\n  // Do a global replace of the element, unable to do this at a lower level.\n  // Ignore this for document fragments, they don't appear in the DOM and we\n  // treat them as transparent containers.\n  if (oldTree.nodeName !== newTree.nodeName && newTree.nodeType !== 11) {\n    // If there is no `parentNode` for the replace operation, we will need to\n    // throw an error and prevent the `StateCache` from being updated.\n    if (!domNode.parentNode) {\n      throw new Error('Unable to replace top level node without a parent');\n    }\n\n    transaction.patches = {\n      TREE_OPS: [{ REPLACE_CHILD: [newTree, oldTree] }],\n      SET_ATTRIBUTE: [],\n      REMOVE_ATTRIBUTE: [],\n      NODE_VALUE: []\n    };\n\n    unprotectVTree(transaction.oldTree);\n    transaction.oldTree = transaction.state.oldTree = newTree;\n    protectVTree(transaction.oldTree);\n\n    // Update the StateCache since we are changing the top level element.\n    StateCache.delete(domNode);\n    StateCache.set(createNode(newTree), transaction.state);\n  }\n  // Otherwise only diff the children.\n  else {\n      transaction.patches = syncTree(oldTree, newTree);\n    }\n\n  measure('sync trees');\n}","import { TransitionCache } from './util/caches';\nimport process from './util/process';\n\n// Available transition states.\nconst stateNames = ['attached', 'detached', 'replaced', 'attributeChanged', 'textChanged'];\n\n// Sets up the states up so we can add and remove events from the sets.\nstateNames.forEach(stateName => TransitionCache.set(stateName, new Set()));\n\nexport function addTransitionState(stateName, callback) {\n  if (process.env.NODE_ENV !== 'production') {\n    if (!stateName || !stateNames.includes(stateName)) {\n      throw new Error(`Invalid state name '${stateName}'`);\n    }\n\n    if (!callback) {\n      throw new Error('Missing transition state callback');\n    }\n  }\n\n  TransitionCache.get(stateName).add(callback);\n}\n\nexport function removeTransitionState(stateName, callback) {\n  if (process.env.NODE_ENV !== 'production') {\n    // Only validate the stateName if the caller provides one.\n    if (stateName && !stateNames.includes(stateName)) {\n      throw new Error(`Invalid state name '${stateName}'`);\n    }\n  }\n\n  // Remove all transition callbacks from state.\n  if (!callback && stateName) {\n    TransitionCache.get(stateName).clear();\n  }\n  // Remove a specific transition callback.\n  else if (stateName && callback) {\n      TransitionCache.get(stateName).delete(callback);\n    }\n    // Remove all callbacks.\n    else {\n        for (let i = 0; i < stateNames.length; i++) {\n          TransitionCache.get(stateNames[i]).clear();\n        }\n      }\n}\n\nexport function runTransitions(setName, ...args) {\n  const set = TransitionCache.get(setName);\n  const promises = [];\n\n  if (!set.size) {\n    return promises;\n  }\n\n  // Ignore text nodes.\n  if (setName !== 'textChanged' && args[0].nodeType === 3) {\n    return promises;\n  }\n\n  // Run each transition callback, if on the attached/detached.\n  set.forEach(callback => {\n    const retVal = callback(...args);\n\n    // Is a `thennable` object or Native Promise.\n    if (typeof retVal === 'object' && retVal.then) {\n      promises.push(retVal);\n    }\n  });\n\n  if (setName === 'attached' || setName === 'detached') {\n    const element = args[0];\n\n    [...element.childNodes].forEach(childNode => {\n      promises.push(...runTransitions(setName, childNode, ...args.slice(1)));\n    });\n  }\n\n  return promises;\n}","import createNode from './create';\nimport { runTransitions } from '../transition';\nimport { NodeCache, TransitionCache } from '../util/caches';\nimport { protectVTree, unprotectVTree } from '../util/memory';\nimport decodeEntities from '../util/decode-entities';\nimport escape from '../util/escape';\n\nconst blockText = new Set(['script', 'noscript', 'style', 'code', 'template']);\nconst blacklist = new Set();\nconst whitelist = new Set();\n\nconst removeAttribute = (domNode, name) => {\n  domNode.removeAttribute(name);\n\n  // Runtime checking if the property can be set.\n  const blacklistName = domNode.nodeName + '-' + name;\n\n  if (whitelist.has(blacklistName)) {\n    domNode[name] = undefined;\n  } else if (!blacklist.has(blacklistName)) {\n    try {\n      domNode[name] = undefined;\n      whitelist.add(blacklistName);\n    } catch (unhandledException) {\n      blacklist.add(blacklistName);\n    }\n  }\n};\n\nexport default function patchNode(patches, state = {}) {\n  const promises = [];\n  const { TREE_OPS, NODE_VALUE, SET_ATTRIBUTE, REMOVE_ATTRIBUTE } = patches;\n  const { isSVG, ownerDocument } = state;\n\n  // Set attributes.\n  if (SET_ATTRIBUTE.length) {\n    for (let i = 0; i < SET_ATTRIBUTE.length; i += 3) {\n      const vTree = SET_ATTRIBUTE[i];\n      const _name = SET_ATTRIBUTE[i + 1];\n      const value = decodeEntities(SET_ATTRIBUTE[i + 2]);\n\n      const domNode = createNode(vTree, ownerDocument, isSVG);\n      const oldValue = domNode.getAttribute(_name);\n      const newPromises = runTransitions('attributeChanged', domNode, _name, oldValue, value);\n\n      // Triggered either synchronously or asynchronously depending on if a\n      // transition was invoked.\n      const isObject = typeof value === 'object';\n      const isFunction = typeof value === 'function';\n\n      // Events must be lowercased otherwise they will not be set correctly.\n      const name = _name.indexOf('on') === 0 ? _name.toLowerCase() : _name;\n\n      // Runtime checking if the property can be set.\n      const blacklistName = vTree.nodeName + '-' + name;\n\n      // Normal attribute value.\n      if (!isObject && !isFunction && name) {\n        const noValue = value === null || value === undefined;\n\n        if (whitelist.has(blacklistName)) {\n          domNode[name] = value;\n        } else if (!blacklist.has(blacklistName)) {\n          try {\n            domNode[name] = value;\n            whitelist.add(blacklistName);\n          } catch (unhandledException) {\n            blacklist.add(blacklistName);\n          }\n        }\n\n        // Set the actual attribute, this will ensure attributes like\n        // `autofocus` aren't reset by the property call above.\n        domNode.setAttribute(name, noValue ? '' : value);\n      }\n      // Support patching an object representation of the style object.\n      else if (isObject && name === 'style') {\n          const keys = Object.keys(value);\n\n          for (let i = 0; i < keys.length; i++) {\n            domNode.style[keys[i]] = value[keys[i]];\n          }\n        } else if (typeof value !== 'string') {\n          // Since this is a property value it gets set directly on the node.\n          if (whitelist.has(blacklistName)) {\n            domNode[name] = value;\n          } else if (!blacklist.has(blacklistName)) {\n            try {\n              domNode[name] = value;\n              whitelist.add(blacklistName);\n            } catch (unhandledException) {\n              blacklist.add(blacklistName);\n            }\n          }\n        }\n\n      if (newPromises.length) {\n        promises.push(...newPromises);\n      }\n    }\n  }\n\n  // Remove attributes.\n  if (REMOVE_ATTRIBUTE.length) {\n    for (let i = 0; i < REMOVE_ATTRIBUTE.length; i += 2) {\n      const vTree = REMOVE_ATTRIBUTE[i];\n      const name = REMOVE_ATTRIBUTE[i + 1];\n\n      const domNode = NodeCache.get(vTree);\n      const attributeChanged = TransitionCache.get('attributeChanged');\n\n      const oldValue = domNode.getAttribute(name);\n      const newPromises = runTransitions('attributeChanged', domNode, name, oldValue, null);\n\n      if (newPromises.length) {\n        Promise.all(newPromises).then(() => removeAttribute(domNode, name));\n        promises.push(...newPromises);\n      } else {\n        removeAttribute(domNode, name);\n      }\n    }\n  }\n\n  // Once attributes have been synchronized into the DOM Nodes, assemble the\n  // DOM Tree.\n  for (let i = 0; i < TREE_OPS.length; i++) {\n    const { INSERT_BEFORE, REMOVE_CHILD, REPLACE_CHILD } = TREE_OPS[i];\n\n    // Insert/append elements.\n    if (INSERT_BEFORE && INSERT_BEFORE.length) {\n      for (let i = 0; i < INSERT_BEFORE.length; i += 3) {\n        const vTree = INSERT_BEFORE[i];\n        const newTree = INSERT_BEFORE[i + 1];\n        const refTree = INSERT_BEFORE[i + 2];\n\n        const domNode = NodeCache.get(vTree);\n        const refNode = refTree && createNode(refTree, ownerDocument, isSVG);\n        const attached = TransitionCache.get('attached');\n\n        if (refTree) {\n          protectVTree(refTree);\n        }\n\n        const newNode = createNode(newTree, ownerDocument, isSVG);\n        protectVTree(newTree);\n\n        // If refNode is `null` then it will simply append like `appendChild`.\n        domNode.insertBefore(newNode, refNode);\n\n        const attachedPromises = runTransitions('attached', newNode);\n\n        promises.push(...attachedPromises);\n      }\n    }\n\n    // Remove elements.\n    if (REMOVE_CHILD && REMOVE_CHILD.length) {\n      for (let i = 0; i < REMOVE_CHILD.length; i++) {\n        const vTree = REMOVE_CHILD[i];\n        const domNode = NodeCache.get(vTree);\n        const detached = TransitionCache.get('detached');\n        const detachedPromises = runTransitions('detached', domNode);\n\n        if (detachedPromises.length) {\n          Promise.all(detachedPromises).then(() => {\n            domNode.parentNode.removeChild(domNode);\n            unprotectVTree(vTree);\n          });\n\n          promises.push(...detachedPromises);\n        } else {\n          domNode.parentNode.removeChild(domNode);\n          unprotectVTree(vTree);\n        }\n      }\n    }\n\n    // Replace elements.\n    if (REPLACE_CHILD && REPLACE_CHILD.length) {\n      for (let i = 0; i < REPLACE_CHILD.length; i += 2) {\n        const newTree = REPLACE_CHILD[i];\n        const oldTree = REPLACE_CHILD[i + 1];\n\n        const oldDomNode = NodeCache.get(oldTree);\n        const newDomNode = createNode(newTree, ownerDocument, isSVG);\n        const attached = TransitionCache.get('attached');\n        const detached = TransitionCache.get('detached');\n        const replaced = TransitionCache.get('replaced');\n\n        // Always insert before to allow the element to transition.\n        oldDomNode.parentNode.insertBefore(newDomNode, oldDomNode);\n        protectVTree(newTree);\n\n        const attachedPromises = runTransitions('attached', newDomNode);\n        const detachedPromises = runTransitions('detached', oldDomNode);\n        const replacedPromises = runTransitions('replaced', oldDomNode, newDomNode);\n        const allPromises = [...attachedPromises, ...detachedPromises, ...replacedPromises];\n\n        if (allPromises.length) {\n          Promise.all(allPromises).then(() => {\n            oldDomNode.parentNode.replaceChild(newDomNode, oldDomNode);\n            unprotectVTree(oldTree);\n          });\n\n          promises.push(...allPromises);\n        } else {\n          oldDomNode.parentNode.replaceChild(newDomNode, oldDomNode);\n          unprotectVTree(oldTree);\n        }\n      }\n    }\n  }\n\n  // Change all nodeValues.\n  if (NODE_VALUE.length) {\n    for (let i = 0; i < NODE_VALUE.length; i += 3) {\n      const vTree = NODE_VALUE[i];\n      const nodeValue = NODE_VALUE[i + 1];\n      const oldValue = NODE_VALUE[i + 2];\n      const domNode = createNode(vTree);\n      const textChanged = TransitionCache.get('textChanged');\n      const textChangedPromises = runTransitions('textChanged', domNode, oldValue, nodeValue);\n\n      const { parentNode } = domNode;\n\n      if (nodeValue.includes('&')) {\n        domNode.nodeValue = decodeEntities(nodeValue);\n      } else {\n        domNode.nodeValue = nodeValue;\n      }\n\n      if (parentNode && blockText.has(parentNode.nodeName.toLowerCase())) {\n        parentNode.nodeValue = escape(decodeEntities(nodeValue));\n      }\n\n      if (textChangedPromises.length) {\n        promises.push(...textChangedPromises);\n      }\n    }\n  }\n\n  return promises;\n}","import patchNode from '../node/patch';\n\n/**\n * Processes a set of patches onto a tracked DOM Node.\n *\n * @param {Object} node - DOM Node to process patchs on\n * @param {Array} patches - Contains patch objects\n */\nexport default function patch(transaction) {\n  const { domNode, state, state: { measure }, patches } = transaction;\n  const { promises = [] } = transaction;\n  const { nodeName } = domNode;\n\n  const namespaceURI = domNode.namespaceURI || '';\n\n  state.isSVG = nodeName.toLowerCase() === 'svg' || namespaceURI.includes('svg');\n  state.ownerDocument = domNode.ownerDocument || document;\n\n  measure('patch node');\n  promises.push(...patchNode(patches, state));\n  measure('patch node');\n\n  transaction.promises = promises;\n}","// End flow, this terminates the transaction and returns a Promise that\n// resolves when completed. If you want to make diffHTML return streams or\n// callbacks replace this function.\nexport default function endAsPromise(transaction) {\n  const { promises = [] } = transaction;\n\n  // Operate synchronously unless opted into a Promise-chain. Doesn't matter\n  // if they are actually Promises or not, since they will all resolve\n  // eventually with `Promise.all`.\n  if (promises.length) {\n    return transaction.promise = Promise.all(promises).then(() => transaction.end());\n  }\n\n  // Pass off the remaining middleware to allow users to dive into the\n  // transaction completed lifecycle event.\n  return transaction.promise = Promise.resolve(transaction.end());\n}","var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nimport { StateCache, MiddlewareCache } from './util/caches';\nimport { cleanMemory, protectVTree } from './util/memory';\nimport makeMeasure from './util/make-measure';\nimport process from './util/process';\nimport schedule from './tasks/schedule';\nimport shouldUpdate from './tasks/should-update';\nimport reconcileTrees from './tasks/reconcile-trees';\nimport syncTrees from './tasks/sync-trees';\nimport patchNode from './tasks/patch-node';\nimport endAsPromise from './tasks/end-as-promise';\n\nexport const defaultTasks = [schedule, shouldUpdate, reconcileTrees, syncTrees, patchNode, endAsPromise];\n\nexport const tasks = {\n  schedule, shouldUpdate, reconcileTrees, syncTrees, patchNode, endAsPromise\n};\n\nlet Transaction = function () {\n  _createClass(Transaction, null, [{\n    key: 'create',\n    value: function create(domNode, markup, options) {\n      return new Transaction(domNode, markup, options);\n    }\n  }, {\n    key: 'flow',\n    value: function flow(transaction, tasks) {\n      let retVal = transaction;\n\n      // Execute each \"task\" serially, passing the transaction as a baton that\n      // can be used to share state across the tasks.\n      for (let i = 0; i < tasks.length; i++) {\n        // If aborted, don't execute any more tasks.\n        if (transaction.aborted) {\n          return retVal;\n        }\n\n        // Run the task.\n        retVal = tasks[i](transaction);\n\n        // The last `returnValue` is what gets sent to the consumer. This\n        // mechanism is crucial for the `abort`, if you want to modify the \"flow\"\n        // that's fine, but you must ensure that your last task provides a\n        // mechanism to know when the transaction completes. Something like\n        // callbacks or a Promise.\n        if (retVal !== undefined && retVal !== transaction) {\n          return retVal;\n        }\n      }\n    }\n  }, {\n    key: 'assert',\n    value: function assert(transaction) {\n      if (process.env.NODE_ENV !== 'production') {\n        if (typeof transaction.domNode !== 'object') {\n          throw new Error('Transaction requires a DOM Node mount point');\n        }\n\n        if (transaction.aborted && transaction.completed) {\n          throw new Error('Transaction was previously aborted');\n        }\n\n        if (transaction.completed) {\n          throw new Error('Transaction was previously completed');\n        }\n      }\n    }\n  }, {\n    key: 'invokeMiddleware',\n    value: function invokeMiddleware(transaction) {\n      const { tasks } = transaction;\n\n      MiddlewareCache.forEach(fn => {\n        // Invoke all the middleware passing along this transaction as the only\n        // argument. If they return a value (must be a function) it will be added\n        // to the transaction task flow.\n        const result = fn(transaction);\n\n        if (result) {\n          tasks.push(result);\n        }\n      });\n    }\n  }]);\n\n  function Transaction(domNode, markup, options) {\n    _classCallCheck(this, Transaction);\n\n    this.domNode = domNode;\n    this.markup = markup;\n    this.options = options;\n\n    this.state = StateCache.get(domNode) || {\n      measure: makeMeasure(domNode, markup)\n    };\n\n    this.tasks = [].concat(options.tasks);\n\n    // Store calls to trigger after the transaction has ended.\n    this.endedCallbacks = new Set();\n\n    StateCache.set(domNode, this.state);\n  }\n\n  _createClass(Transaction, [{\n    key: 'start',\n    value: function start() {\n      if (process.env.NODE_ENV !== 'production') {\n        Transaction.assert(this);\n      }\n\n      const { domNode, state: { measure }, tasks } = this;\n      const takeLastTask = tasks.pop();\n\n      this.aborted = false;\n\n      // Add middleware in as tasks.\n      Transaction.invokeMiddleware(this);\n\n      // Measure the render flow if the user wants to track performance.\n      measure('render');\n\n      // Push back the last task as part of ending the flow.\n      tasks.push(takeLastTask);\n\n      return Transaction.flow(this, tasks);\n    }\n\n    // This will immediately call the last flow task and terminate the flow. We\n    // call the last task to ensure that the control flow completes. This should\n    // end psuedo-synchronously. Think `Promise.resolve()`, `callback()`, and\n    // `return someValue` to provide the most accurate performance reading. This\n    // doesn't matter practically besides that.\n\n  }, {\n    key: 'abort',\n    value: function abort(isReturn) {\n      const { state } = this;\n\n      this.aborted = true;\n\n      // Grab the last task in the flow and return, this task will be responsible\n      // for calling `transaction.end`.\n      if (isReturn) {\n        return this.tasks[this.tasks.length - 1](this);\n      }\n    }\n  }, {\n    key: 'end',\n    value: function end() {\n      const { state, domNode, options } = this;\n      const { measure } = state;\n      const { inner } = options;\n\n      measure('finalize');\n\n      this.completed = true;\n\n      // Mark the end to rendering.\n      measure('finalize');\n      measure('render');\n\n      // Trigger all `onceEnded` callbacks, so that middleware can know the\n      // transaction has ended.\n      this.endedCallbacks.forEach(callback => callback(this));\n      this.endedCallbacks.clear();\n\n      // Cache the markup and text for the DOM node to allow for short-circuiting\n      // future render transactions.\n      state.previousMarkup = domNode.outerHTML;\n      state.isRendering = false;\n\n      // Clean up memory before rendering the next transaction, however if\n      // another transaction is running concurrently this will be delayed until\n      // the last render completes.\n      cleanMemory();\n\n      return this;\n    }\n  }, {\n    key: 'onceEnded',\n    value: function onceEnded(callback) {\n      this.endedCallbacks.add(callback);\n    }\n  }]);\n\n  return Transaction;\n}();\n\nexport default Transaction;","import Transaction, { defaultTasks } from './transaction';\n\nexport default function innerHTML(domNode, markup = '', options = {}) {\n  options.inner = true;\n  options.tasks = options.tasks || defaultTasks;\n  return Transaction.create(domNode, markup, options).start();\n}","import Transaction, { defaultTasks } from './transaction';\n\nexport default function outerHTML(domNode, markup = '', options = {}) {\n  options.inner = false;\n  options.tasks = options.tasks || defaultTasks;\n  return Transaction.create(domNode, markup, options).start();\n}","import createTree from './tree/create';\nimport parse from './util/parse';\nimport escape from './util/escape';\nimport decodeEntities from './util/decode-entities';\n\nconst { isArray } = Array;\nconst isTagEx = /(<|\\/)/;\nconst TOKEN = '__DIFFHTML__';\n\n// Get the next value from the list. If the next value is a string, make sure\n// it is escaped.\nconst nextValue = values => {\n  const value = values.shift();\n  return typeof value === 'string' ? escape(decodeEntities(value)) : value;\n};\n\nexport default function handleTaggedTemplate(strings, ...values) {\n  // If this function is used outside of a tagged template, ensure that flat\n  // strings are coerced to arrays, simulating a tagged template call.\n  if (typeof strings === 'string') {\n    strings = [strings];\n  }\n\n  // Do not attempt to parse empty strings.\n  if (!strings) {\n    return null;\n  }\n\n  // Parse only the text, no dynamic bits.\n  if (strings.length === 1 && !values.length) {\n    const strict = handleTaggedTemplate.isStrict;\n    handleTaggedTemplate.isStrict = undefined;\n    const { childNodes } = parse(strings[0], null, { strict });\n    return childNodes.length > 1 ? createTree(childNodes) : childNodes[0];\n  }\n\n  // Used to store markup and tokens.\n  let HTML = '';\n\n  // We filter the supplemental values by where they are used. Values are\n  // either, children, or tags (for components).\n  const supplemental = { attributes: {}, children: {}, tags: {} };\n\n  // Loop over the static strings, each break correlates to an interpolated\n  // value. As these values can be dynamic, we cannot pass them to the HTML\n  // parser inline (it only accepts strings). These dynamic values are indexed\n  // in an object called supplemental and keyed by a incremental string token.\n  // The following loop instruments the markup with these tokens that the\n  // parser then uses to assemble the correct tree.\n  strings.forEach((string, i) => {\n    // Always add the string, we need it to parse the markup later.\n    HTML += string;\n\n    // If there are values, figure out where in the markup they were injected.\n    if (values.length) {\n      const value = nextValue(values);\n      const lastSegment = string.split(' ').pop();\n      const lastCharacter = HTML.trim().slice(-1);\n      const isAttribute = HTML.lastIndexOf('>') < HTML.lastIndexOf('<');\n      const isTag = Boolean(lastCharacter.match(isTagEx));\n      const isString = typeof value === 'string';\n      const isObject = typeof value === 'object';\n      const _isArray = isArray(value);\n      const token = `${TOKEN}${i}__`;\n\n      // Injected as a tag.\n      if (isTag && !isString) {\n        supplemental.tags[i] = value;\n        HTML += token;\n      }\n      // Injected as attribute.\n      else if (isAttribute) {\n          supplemental.attributes[i] = value;\n          HTML += token;\n        }\n        // Injected as a child node.\n        else if (_isArray || isObject) {\n            supplemental.children[i] = createTree(value);\n            HTML += token;\n          }\n          // Injected as something else in the markup or undefined, ignore\n          // obviously falsy values used with boolean operators.\n          else if (value) {\n              HTML += value;\n            }\n    }\n  });\n\n  // Determine if we are in strict mode and immediately reset for the next\n  // call.\n  const strict = handleTaggedTemplate.isStrict;\n  handleTaggedTemplate.isStrict = undefined;\n\n  // Parse the instrumented markup to get the Virtual Tree.\n  const { childNodes } = parse(HTML, supplemental, { strict });\n\n  // This makes it easier to work with a single element as a root, opposed to\n  // always returning an array.\n  return childNodes.length === 1 ? childNodes[0] : createTree(childNodes);\n}\n\n// Use a strict mode similar to XHTML/JSX where tags must be properly closed\n// and malformed markup is treated as an error. The default is to silently fail\n// just like HTML.\nhandleTaggedTemplate.strict = (...args) => {\n  handleTaggedTemplate.isStrict = true;\n  return handleTaggedTemplate(...args);\n};","import { StateCache } from './util/caches';\nimport { cleanMemory, unprotectVTree } from './util/memory';\n\nexport default function release(domNode) {\n  // Try and find a state object for this DOM Node.\n  const state = StateCache.get(domNode);\n\n  // If there is a Virtual Tree element, recycle all objects allocated for it.\n  if (state && state.oldTree) {\n    unprotectVTree(state.oldTree);\n  }\n\n  // Remove the DOM Node's state object from the cache.\n  StateCache.delete(domNode);\n\n  // Recycle all unprotected objects.\n  cleanMemory();\n}","import { MiddlewareCache } from './util/caches';\nimport process from './util/process';\n\nconst {\n  CreateTreeHookCache,\n  CreateNodeHookCache,\n  SyncTreeHookCache,\n  ReleaseHookCache\n} = MiddlewareCache;\n\nexport default function use(middleware) {\n  if (process.env.NODE_ENV !== 'production') {\n    if (typeof middleware !== 'function') {\n      throw new Error('Middleware must be a function');\n    }\n  }\n\n  const {\n    subscribe,\n    unsubscribe,\n    createTreeHook,\n    createNodeHook,\n    syncTreeHook,\n    releaseHook\n  } = middleware;\n\n  // Add the function to the set of middlewares.\n  MiddlewareCache.add(middleware);\n\n  // Call the subscribe method if it was defined, passing in the full public\n  // API we have access to at this point.\n  subscribe && middleware.subscribe();\n\n  // Add the hyper-specific create hooks.\n  createTreeHook && CreateTreeHookCache.add(createTreeHook);\n  createNodeHook && CreateNodeHookCache.add(createNodeHook);\n  syncTreeHook && SyncTreeHookCache.add(syncTreeHook);\n  releaseHook && ReleaseHookCache.add(releaseHook);\n\n  // The unsubscribe method for the middleware.\n  return () => {\n    // Remove this middleware from the internal cache. This will prevent it\n    // from being invoked in the future.\n    MiddlewareCache.delete(middleware);\n\n    // Call the unsubscribe method if defined in the middleware (allows them\n    // to cleanup).\n    unsubscribe && unsubscribe();\n\n    // Cleanup the specific fns from their Cache.\n    CreateTreeHookCache.delete(createTreeHook);\n    CreateNodeHookCache.delete(createNodeHook);\n    SyncTreeHookCache.delete(syncTreeHook);\n    ReleaseHookCache.delete(releaseHook);\n  };\n}","export const __VERSION__ = '1.0.0-beta.9';","import createTree from './tree/create';\nimport syncTree from './tree/create';\nimport createNode from './node/create';\nimport parseNewTree from './tasks/parse-new-tree';\nimport reconcileTrees from './tasks/reconcile-trees';\nimport internals from './util/internals';\nimport parse from './util/parse';\nimport innerHTML from './inner-html';\nimport outerHTML from './outer-html';\nimport { defaultTasks, tasks } from './transaction';\nimport html from './html';\nimport release from './release';\nimport use from './use';\nimport { addTransitionState, removeTransitionState } from './transition';\nimport { __VERSION__ as VERSION } from './version';\n\n// At startup inject the HTML parser into the default set of tasks.\ndefaultTasks.splice(defaultTasks.indexOf(reconcileTrees), 0, parseNewTree);\n\nconst api = {\n  VERSION,\n  addTransitionState,\n  removeTransitionState,\n  release,\n  createTree,\n  use,\n  outerHTML,\n  innerHTML,\n  html\n};\n\nconst { assign } = Object;\n\n// This is an internal API exported purely for middleware and extensions to\n// leverage internal APIs that are not part of the public API. There are no\n// promises that this will not break in the future. We will attempt to minimize\n// changes and will supply fallbacks when APIs change.\n//\n// Note: The HTML parser is only available in this mode.\nconst Internals = assign(internals, api, {\n  parse,\n  defaultTasks,\n  tasks,\n  createNode,\n  syncTree\n});\n\n// Attach a circular reference to `Internals` for ES/CJS builds.\napi.Internals = Internals;\n\n// Automatically hook up to DevTools if they are present.\nif (typeof devTools !== 'undefined') {\n  use(devTools(Internals));\n  console.warn('diffHTML DevTools: Found and Activated...');\n}\n\nexport { VERSION, addTransitionState, removeTransitionState, release, createTree, use, outerHTML, innerHTML, html, Internals };\n\nexport default api;","import { Plugin } from \"./plugin\";\r\nimport { innerHTML as diffInnerHTML } from \"diffhtml\";\r\nimport { StatefulWidget} from \"../StatefulWidget\";\r\n\r\nexport class DiffingPlugin implements Plugin {\r\n    private differ: (a: HTMLElement, b: string | HTMLElement) => any\r\n    constructor(public widget: StatefulWidget){\r\n        this.differ = diffInnerHTML\r\n    }\r\n\r\n    public run(innerHTML: string) {\r\n        this.differ(this.widget, innerHTML);\r\n    }\r\n}","import { Plugin } from \"./plugin\";\r\nimport { Widget } from \"../Widget\";\r\n\r\nexport class TemplateParserPlugin implements Plugin {\r\n    constructor(public widget: Widget) {\r\n\r\n    }\r\n\r\n    public run(innerHTML: string){\r\n        (innerHTML.match(/\\{([^}]+)\\}/g)||[]).forEach(t => {\r\n            t = t.slice(2,-1);\r\n            const res = new Function(`return (${t});`)\r\n            const ev = res.call(this.widget)\r\n            this.widget.innerHTML = this.widget.innerHTML.replace(\"{{\"+t+\"}}\", ev);\r\n        });\r\n    }\r\n}","import { State, StateTransformers } from \"./utils\";\r\nimport { EventEmitter } from \"events\";\r\nimport { Widget } from \"./Widget\";\r\nimport { DiffingPlugin } from \"./plugins/diffing\";\r\nimport { Plugin } from \"./plugins/plugin\";\r\nimport { TemplateParserPlugin } from \"./plugins/templatePraser\";\r\n\r\nexport class StatefulWidget extends Widget {\r\n    protected cachedState: State;\r\n    private plugins: Array<Plugin> = [new DiffingPlugin(this), new TemplateParserPlugin(this)];\r\n    eventEmitter = new EventEmitter();\r\n    constructor(state: State, transformers?: StateTransformers){\r\n        super(state, transformers);\r\n        this.setState(state);\r\n        this.on('load',this.onMount)\r\n    }\r\n\r\n    connectedCallback(){\r\n        this.setup();\r\n        this.root = this;\r\n        let state: State = {};\r\n        for(let i=0; i<this.attributes.length; i++){\r\n            const attr= this.attributes[i];\r\n            state[attr.name] = attr.value;\r\n        }\r\n        let componentState = Object.assign({}, this.state)\r\n        state = Object.assign(componentState, state);\r\n        this.beforeRender()\r\n        this.runPlugins(this._render(state));\r\n        this.on('render',(state: State)=>{\r\n            componentState = Object.assign({}, this.cachedState || this.state)\r\n            let _state = Object.assign(state, componentState);\r\n            this.beforeRender()\r\n            this.runPlugins(this._render(_state));\r\n            this.afterRender()\r\n        })\r\n        this.emit('load')\r\n        this.afterRender()\r\n    }\r\n\r\n    private runPlugins(innerHTML: string){\r\n        for(const plugin of this.plugins){\r\n            plugin.run(innerHTML)\r\n        }\r\n    }\r\n\r\n    get emitter(){\r\n        return this.eventEmitter;\r\n    }\r\n\r\n    get on(){\r\n        return this.eventEmitter.on;\r\n    }\r\n\r\n    get emit(){\r\n        return this.eventEmitter.emit;\r\n    }\r\n\r\n    peerComponent(component: StatefulWidget){\r\n        component.on('render',()=>{\r\n            this.emit('render', this.cachedState || this.state);\r\n        })\r\n    }\r\n\r\n    cacheState(): any{\r\n        this.cachedState = Object.assign({},this.state);\r\n        return this.cachedState;\r\n    }\r\n\r\n    setState(state: State){\r\n        this.transformers && Object.keys(this.state).length !== 0 && this.transformState(this.transformers,this.state)\r\n        // console.log(this.cachedState, this.state)\r\n        this.state = Object.assign( this.cachedState || this.state || {}, state);\r\n        this.emit('render',this.state);\r\n    }\r\n    \r\n    public beforeRender(){}\r\n    public afterRender(){}\r\n}","import { getRef, State, StateTransformers } from \"./utils\";\r\nimport { Widget } from \"./Widget\";\r\n\r\nexport class StatelessWidget extends Widget {\r\n\r\n    constructor(state: State, transformers?: StateTransformers){\r\n        super(state, transformers);\r\n    }\r\n\r\n    connectedCallback(){\r\n        this.setup();\r\n        this.root = this;\r\n        let state: State = {};\r\n        for(let i=0; i<this.attributes.length; i++){\r\n            const attr= this.attributes[i];\r\n            state[attr.name] = attr.value;\r\n        }\r\n        let componentState = {};\r\n        Object.assign(componentState, this.state)\r\n        Object.assign(componentState, state);\r\n        this.innerHTML = this._render(componentState);\r\n        this.onMount()\r\n    }\r\n    \r\n}","import { Root } from \"./Root\";\nimport { useComponent } from \"widgetsjs\";\nimport { Card } from \"./Card\";\nimport { Button } from \"./Button\";\nimport { Content } from \"./Content\";\nuseComponent(Root).as('x-root')\nuseComponent(Card).as('x-card')\nuseComponent(Content).as('x-content')\nuseComponent(Button).as('x-next')","import { StatelessWidget } from \"widgetsjs\";\n\nexport class Root extends StatelessWidget {\n    constructor(){\n        super({})\n    }\n\n    render(state){\n        return this.widgetChildren;\n    }\n}\n","import { StatelessWidget } from \"widgetsjs\";\n\nexport class Card extends StatelessWidget {\n    constructor(){\n        super({})\n    }\n\n    render(){\n        return `\n        <div class=\"card\">\n            ${this.widgetChildren}\n        </div>\n        `\n    }\n}","import { StatefulWidget } from \"widgetsjs\";\n\nexport class Button extends StatefulWidget {\n    constructor(){\n        super({\n            disabled: true\n        },{\n            disabled: e=>e === true || e == 'true'\n        })\n    }\n\n    onMount(){\n        const btn = this.$child<HTMLButtonElement>('button');\n        btn.addEventListener('click', () => {\n            window.open('http://localhost:10000/Applications/com.owl.home/index.html', '_self')\n        })\n    }\n\n    afterRender(){\n        this.$child<HTMLButtonElement>('button').disabled = this.state.disabled;\n    }\n\n    render(state){\n        console.log(state)\n        return `<button class=\"${state.disabled ? 'inactive': 'active'}\">${this.widgetChildren}</button>`;\n    }\n}","import { StatelessWidget, StatefulWidget } from \"widgetsjs\";\n\nconst license = `Copyright (c) 2020, Tsowa Mainasara Al-amin \nAll rights reserved. \n\nRedistribution and use in source and binary forms, with or without \nmodification, are permitted provided that the following conditions are met: \n\n * Redistributions of source code must retain the above copyright notice, \n   this list of conditions and the following disclaimer. \n * Redistributions in binary form must reproduce the above copyright \n   notice, this list of conditions and the following disclaimer in the \n   documentation and/or other materials provided with the distribution. \n * Neither the name of OWL nor the names of its contributors may be used to \n   endorse or promote products derived from this software without specific \n   prior written permission. \n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" \nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE \nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE \nARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE \nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR \nCONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF \nSUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS \nINTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN \nCONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) \nARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE \nPOSSIBILITY OF SUCH DAMAGE. \n`\n\nexport class Content extends StatefulWidget {\n    constructor(){\n        super({})\n    }\n\n    onMount(){\n        const cb = this.$child<HTMLInputElement>('input');\n        cb.addEventListener('click', ()=>{\n            console.log(!cb.checked)\n            this.$ref<StatefulWidget>('next').setState({\n                disabled: (!cb.checked).toString()\n            });\n        })\n    }\n\n    render(){\n        return `\n            <h1>Welcome to OWL-OS</h1>\n            <pre>${license}</pre>\n            <label><input type=\"checkbox\"/>Agree to terms</label>\n            <br/>\n        `\n    }\n}","import { Root } from \"./Root\";\nimport { useComponent } from \"widgetsjs\";\nimport { Card } from \"./Card\";\nimport { Button } from \"./Button\";\nimport { Content } from \"./Content\";\nuseComponent(Root).as('x-root')\nuseComponent(Card).as('x-card')\nuseComponent(Content).as('x-content')\nuseComponent(Button).as('x-next')"]}